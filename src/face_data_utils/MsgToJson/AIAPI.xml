<?xml version="1.0"?>
<doc>
    <assembly>
        <name>AIAPI</name>
    </assembly>
    <members>
        <member name="T:KKAPI.KoikatuAPI">
            <summary>
            Provides overall information about the game and the API itself, and provides some useful tools.
            More information is available in project wiki at https://github.com/ManlyMarco/KKAPI/wiki
            </summary>
        </member>
        <member name="F:KKAPI.KoikatuAPI.StudioProcessName">
            <summary>
            The studio process name for use with <see cref="T:BepInEx.BepInProcess"/> attributes.
            </summary>
        </member>
        <member name="F:KKAPI.KoikatuAPI.GameProcessName">
            <summary>
            The game process name for use with <see cref="T:BepInEx.BepInProcess"/> attributes.
            It's the same for jp and steam releases.
            </summary>
        </member>
        <member name="M:KKAPI.KoikatuAPI.GetCurrentGameMode">
            <summary>
            Get current game mode. 
            </summary>
        </member>
        <member name="M:KKAPI.KoikatuAPI.GetGameVersion">
            <summary>
            Get current version of the game.
            </summary>
        </member>
        <member name="M:KKAPI.KoikatuAPI.IsSteamRelease">
            <summary>
            Check if the game is the Steam release instead of the original Japanese release.
            <remarks>It's best to not rely on this and instead make the same code work in both versions (if possible).</remarks>
            </summary>
        </member>
        <member name="F:KKAPI.KoikatuAPI.VersionConst">
            <summary>
            Version of this assembly/plugin.
            WARNING: This is a const field, therefore it will be copied to your assembly!
            Use this field to check if the installed version of the plugin is up to date by adding this attribute to your plugin class:
            <code>[BepInDependency(KoikatuAPI.GUID, KoikatuAPI.VersionConst)]</code>
            THIS VALUE WILL NOT BE READ FROM THE INSTALLED VERSION, YOU WILL READ THE VALUE FROM THIS VERSION THAT YOU COMPILE YOUR PLUGIN AGAINST!
            More info: https://stackoverflow.com/questions/55984/what-is-the-difference-between-const-and-readonly
            </summary>
        </member>
        <member name="F:KKAPI.KoikatuAPI.GUID">
            <summary>
            GUID of this plugin, use for checking dependancies with <see cref="T:BepInEx.BepInDependency"/>."/>
            </summary>
        </member>
        <member name="P:KKAPI.KoikatuAPI.EnableDebugLogging">
            <summary>
            Enables display of additional log messages when certain events are triggered within KKAPI. 
            Useful for plugin devs to understand when controller messages are fired.
            </summary>
        </member>
        <member name="P:KKAPI.KoikatuAPI.IsQuitting">
            <summary>
            Can be used to detect if application is currently quitting.
            </summary>
            <value>
              <c>true</c> if application is quitting; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="E:KKAPI.KoikatuAPI.Quitting">
            <summary>
            Occurs when application is quitting.
            Plugins can use this to do things like write config files and caches, or stop outstanding coroutines to prevent shutdown delays.
            Note: This event might not fire if the game isn't closed cleanly (hard crashes, killed process, closing the console window, etc.).
            </summary>
        </member>
        <member name="M:KKAPI.KoikatuAPI.BaseAwake">
            <summary>
            Needs to be called at the start of Awake
            </summary>
        </member>
        <member name="M:KKAPI.KoikatuAPI.CheckRequiredPlugin(BepInEx.BaseUnityPlugin,System.String,System.Version,BepInEx.Logging.LogLevel)">
            <summary>
            Check if a plugin is loaded and has at least the minimum version. 
            If the plugin is missing or older than minimumVersion, user is shown an error message on screen and false is returned.
            Warning: Run only from Start, not from constructor or Awake because some plugins might not be loaded yet!
            </summary>
            <param name="origin">Your plugin</param>
            <param name="guid">Guid of the plugin your plugin is dependant on</param>
            <param name="minimumVersion">Minimum version of the required plugin</param>
            <param name="level">Level of the issue - <code>Error</code> if plugin can't work, <code>Warning</code> if there might be issues, or <code>None</code> to not show any message.</param>
            <returns>True if plugin exists and it's version equals or is newer than minimumVersion, otherwise false</returns>
        </member>
        <member name="M:KKAPI.KoikatuAPI.CheckIncompatiblePlugin(BepInEx.BaseUnityPlugin,System.String,BepInEx.Logging.LogLevel)">
            <summary>
            Check if a plugin that is not compatible with your plugin is loaded. 
            If the plugin is loaded, user is shown a warning message on screen and true is returned.
            Warning: Run only from Start, not from constructor or Awake because some plugins might not be loaded yet!
            </summary>
            <param name="origin">Your plugin</param>
            <param name="guid">Guid of the plugin your plugin is incompatible with</param>
            <param name="level">Level of the issue - <code>Error</code> if plugin can't work, <code>Warning</code> if there might be issues, or <code>None</code> to not show any message.</param>
            <returns>True if plugin exists, otherwise false</returns>
        </member>
        <member name="M:KKAPI.KoikatuAPI.SynchronizedInvoke(System.Action)">
            <summary>
            Invoke the Action on the main unity thread. Use to synchronize your threads.
            </summary>
        </member>
        <member name="T:KKAPI.MainGame.GameAPI">
            <summary>
            Provides API for interfacing with the main game. It is useful mostly in the actual game, but some
            functions will work outside of it (for example in FreeH).
            </summary>
        </member>
        <member name="E:KKAPI.MainGame.GameAPI.StartH">
            <summary>
            Fired after an H scene is loaded. Can be both in the main game and in free h.
            Runs immediately after all <see cref="T:KKAPI.MainGame.GameCustomFunctionController"/> objects trigger their events.
            </summary>
        </member>
        <member name="E:KKAPI.MainGame.GameAPI.EndH">
            <summary>
            Fired after an H scene is ended, but before it is unloaded. Can be both in the main game and in free h.
            Runs immediately after all <see cref="T:KKAPI.MainGame.GameCustomFunctionController"/> objects trigger their events.
            </summary>
        </member>
        <member name="E:KKAPI.MainGame.GameAPI.GameLoad">
            <summary>
            Fired right after a game save is succesfully loaded.
            Runs immediately after all <see cref="T:KKAPI.MainGame.GameCustomFunctionController"/> objects trigger their events.
            </summary>
        </member>
        <member name="E:KKAPI.MainGame.GameAPI.GameSave">
            <summary>
            Fired right before the game state is saved to file.
            Runs immediately after all <see cref="T:KKAPI.MainGame.GameCustomFunctionController"/> objects trigger their events.
            </summary>
        </member>
        <member name="P:KKAPI.MainGame.GameAPI.InsideHScene">
            <summary>
            True if any sort of H scene is currently loaded.
            </summary>
        </member>
        <member name="P:KKAPI.MainGame.GameAPI.GameBeingSaved">
            <summary>
            True if the game is in process of being saved.
            </summary>
        </member>
        <member name="M:KKAPI.MainGame.GameAPI.GetBehaviours">
            <summary>
            Get all registered behaviours for the game.
            </summary>
        </member>
        <member name="M:KKAPI.MainGame.GameAPI.GetRegisteredBehaviour(System.String)">
            <summary>
            Get the first controller that was registered with the specified extendedDataId.
            </summary>
        </member>
        <member name="M:KKAPI.MainGame.GameAPI.GetRegisteredBehaviour(System.Type)">
            <summary>
            Get the first controller of the specified type that was registered. The type has to be an exact match.
            </summary>
        </member>
        <member name="M:KKAPI.MainGame.GameAPI.GetRegisteredBehaviour(System.Type,System.String)">
            <summary>
            Get the first controller of the specified type that was registered with the specified extendedDataId. The type has to be an exact match.
            </summary>
        </member>
        <member name="M:KKAPI.MainGame.GameAPI.RegisterExtraBehaviour``1(System.String)">
            <summary>
            Register new functionality that will be added to main game. Offers easy API for custom main game logic.
            All you have to do is create a type that inherits from <see cref="T:KKAPI.MainGame.GameCustomFunctionController"/>>
            (don't make instances, the API will make them for you). Warning: The custom controller is immediately
            created when it's registered, but its OnGameLoad method is not called until a game actually loads.
            This might mean that if the registration happens too late you will potentially miss some load events.
            </summary>
            <typeparam name="T">Type with your custom logic to add to a character</typeparam>
            <param name="extendedDataId">Extended data ID used by this behaviour. Set to null if not used.</param>
        </member>
        <member name="T:KKAPI.MainGame.GameCustomFunctionController">
            <summary>
            Base type for custom game extensions.
            It provides many useful methods that abstract away the nasty hooks needed to figure out when the state of the game
            changes.
            
            This controller is a MonoBehaviour that is created upon registration in <see cref="M:KKAPI.MainGame.GameAPI.RegisterExtraBehaviour``1(System.String)"/>.
            The controller is created only once. If it's created too late it might miss some events.
            It's recommended to register controllers in your Start method.
            </summary>
        </member>
        <member name="P:KKAPI.MainGame.GameCustomFunctionController.ExtendedDataId">
            <summary>
            Extended save ID used by this function controller
            </summary>
        </member>
        <member name="M:KKAPI.MainGame.GameCustomFunctionController.GetExtendedData">
            <summary>
            Get extended data based on supplied ExtendedDataId. When in chara maker loads data from character that's being loaded. 
            </summary>
        </member>
        <member name="M:KKAPI.MainGame.GameCustomFunctionController.SetExtendedData(ExtensibleSaveFormat.PluginData)">
            <summary>
            Save your custom data to the character card under the ID you specified when registering this controller.
            </summary>
            <param name="data">Your custom data to be written to the character card. Can be null to remove the data.</param>
        </member>
        <member name="M:KKAPI.MainGame.GameCustomFunctionController.OnEndH(HScene,System.Boolean)">
            <summary>
            Triggered when the H scene is ended, but before it is unloaded.
            Warning: This is triggered in free H as well!
            </summary>
            <param name="proc">H scene controller instance</param>
            <param name="freeH">If true, the h scene was started from Main menu > Extra > FreeH</param>
        </member>
        <member name="M:KKAPI.MainGame.GameCustomFunctionController.OnGameLoad(KKAPI.MainGame.GameSaveLoadEventArgs)">
            <summary>
            Triggered right after game state was loaded from a file. Some things might still be uninitialized.
            </summary>
        </member>
        <member name="M:KKAPI.MainGame.GameCustomFunctionController.OnGameSave(KKAPI.MainGame.GameSaveLoadEventArgs)">
            <summary>
            Triggered right before game state is saved to a file.
            </summary>
        </member>
        <member name="M:KKAPI.MainGame.GameCustomFunctionController.OnStartH(HScene,System.Boolean)">
            <summary>
            Triggered after an H scene is loaded.
            Warning: This is triggered in free H as well!
            </summary>
            <param name="proc">H scene controller instance</param>
            <param name="freeH">If true, the h scene was started from Main menu > Extra > FreeH</param>
        </member>
        <member name="M:KKAPI.MainGame.GameCustomFunctionController.GetCycle">
            <summary>
            Get the current game EnvironmentSimulator (Cycle in KK) object, if it exists.
            </summary>
        </member>
        <member name="M:KKAPI.MainGame.GameCustomFunctionController.OnDayChange(System.Int32)">
            <summary>
            Triggered when the current day changes in story mode.
            </summary>
        </member>
        <member name="M:KKAPI.MainGame.GameCustomFunctionController.OnPeriodChange(AIProject.TimeZone)">
            <summary>
            Triggered when the current time of the day changes in story mode (morning, noon, night).
            </summary>
        </member>
        <member name="M:KKAPI.MainGame.GameCustomFunctionController.OnNewGame">
            <summary>
            Triggered when a new game is started in story mode.
            </summary>
        </member>
        <member name="T:KKAPI.MainGame.GameSaveLoadEventArgs">
            <summary>
            Arguments used with main game save/load events.
            </summary>
        </member>
        <member name="M:KKAPI.MainGame.GameSaveLoadEventArgs.#ctor(System.String,System.String)">
            <summary>
            Create a new instance
            </summary>
        </member>
        <member name="P:KKAPI.MainGame.GameSaveLoadEventArgs.FileName">
            <summary>
            Name of the safe file.
            </summary>
        </member>
        <member name="P:KKAPI.MainGame.GameSaveLoadEventArgs.FullFilename">
            <summary>
            Full filename of the save file.
            </summary>
        </member>
        <member name="P:KKAPI.MainGame.GameSaveLoadEventArgs.Path">
            <summary>
            Path to which the save file will be written.
            </summary>
        </member>
        <member name="T:KKAPI.MainGame.GameExtensions">
            <summary>
            Extensions useful in the main game
            </summary>
        </member>
        <member name="M:KKAPI.MainGame.GameExtensions.GetHeroine(AIChara.ChaControl)">
            <summary>
            Get the persisting AgentData (heroine) object that describes this character.
            Returns null if the AgentData (heroine) could not be found. Works only in the main game.
            </summary>
        </member>
        <member name="M:KKAPI.MainGame.GameExtensions.GetHeroine(AIChara.ChaFileControl)">
            <summary>
            Get the persisting AgentData (heroine) object that describes this character.
            Returns null if the AgentData (heroine) could not be found. Works only in the main game.
            </summary>
        </member>
        <member name="M:KKAPI.MainGame.GameExtensions.GetNPC(AIProject.SaveData.AgentData)">
            <summary>
            Get the AgentActor that represents this AgentData (heroine) in the game. Works only in the main game.
            If the AgentData (heroine) has not been spawned into the game it returns null.
            </summary>
        </member>
        <member name="M:KKAPI.MainGame.GameExtensions.GetRelatedChaFiles(AIProject.SaveData.AgentData)">
            <summary>
            Get ChaFiles that are related to this AgentData (heroine). Warning: It might not return some copies.
            </summary>
        </member>
        <member name="M:KKAPI.MainGame.GameExtensions.GetRelatedChaFiles(AIProject.AgentActor)">
            <summary>
            Get ChaFiles that are related to this AgentActor (heroine). Warning: It might not return some copies.
            </summary>
        </member>
        <member name="M:KKAPI.MainGame.GameExtensions.GetPlayer(AIChara.ChaControl)">
            <summary>
            Get the persisting player object that describes this character.
            Returns null if the player could not be found. Works only in the main game.
            </summary>
        </member>
        <member name="M:KKAPI.MainGame.GameExtensions.GetPlayer(AIChara.ChaFileControl)">
            <summary>
            Get the persisting player object that describes this character.
            Returns null if the player could not be found. Works only in the main game.
            </summary>
        </member>
        <member name="M:KKAPI.MainGame.GameExtensions.GetRelatedChaFiles(AIProject.PlayerActor)">
            <summary>
            Get ChaFiles that are related to this player. Warning: It might not return some copies.
            </summary>
        </member>
        <member name="T:KKAPI.MainGame.IgnoreCaseEqualityComparer">
            <summary>
            An equality comparer that uses StringComparison.OrdinalIgnoreCase rule
            </summary>
        </member>
        <member name="M:KKAPI.MainGame.IgnoreCaseEqualityComparer.Equals(System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="M:KKAPI.MainGame.IgnoreCaseEqualityComparer.GetHashCode(System.String)">
            <inheritdoc />
        </member>
        <member name="F:KKAPI.MainGame.IgnoreCaseEqualityComparer.Instance">
            <summary>
            Instance of the comparer for use in linq and such
            </summary>
        </member>
        <member name="T:KKAPI.Chara.CharacterApi">
            <summary>
            Provides an easy way to add custom logic to all characters in the game and in studio. 
            It takes care of all the error-prone plumbing and lets you easily save and load data to the character cards.
            </summary>
        </member>
        <member name="T:KKAPI.Chara.CharacterApi.ControllerRegistration">
            <summary>
            Information about a single kind of a <see cref="T:KKAPI.Chara.CharaCustomFunctionController"/>. New kind is created every time
            you call <see cref="M:KKAPI.Chara.CharacterApi.RegisterExtraBehaviour``1(System.String)"/>.
            </summary>
        </member>
        <member name="P:KKAPI.Chara.CharacterApi.ControllerRegistration.Instances">
            <summary>
            All currently existing instances of this kind of controller.
            </summary>
        </member>
        <member name="P:KKAPI.Chara.CharacterApi.ControllerRegistration.ControllerType">
            <summary>
            Type of the custom controller kind.
            </summary>
        </member>
        <member name="P:KKAPI.Chara.CharacterApi.ControllerRegistration.ExtendedDataId">
            <summary>
            ID of the extended data used by this controller kind.
            </summary>
        </member>
        <member name="P:KKAPI.Chara.CharacterApi.ControllerRegistration.ExtendedDataCopier">
            <summary>
            Method used to copy extended data used by this controller in case that's necessary.
            </summary>
        </member>
        <member name="P:KKAPI.Chara.CharacterApi.ControllerRegistration.MaintainState">
            <summary>
            If true, the current state of all controllers of this kind should be preserved inside <see cref="M:KKAPI.Chara.CharaCustomFunctionController.OnReload(KKAPI.GameMode,System.Boolean)"/>.
            New extended data will not be read, instead currently data will be reused, or the reload will not happen at all.
            </summary>
        </member>
        <member name="P:KKAPI.Chara.CharacterApi.ControllerRegistration.MaintainCoordinateState">
            <summary>
            If true, the current state of all controllers of this kind should be preserved inside <see cref="M:KKAPI.Chara.CharaCustomFunctionController.OnCoordinateBeingLoaded(AIChara.ChaFileCoordinate,System.Boolean)"/>.
            New extended data will not be read, instead currently data will be reused, or the load will not happen at all.
            </summary>
        </member>
        <member name="P:KKAPI.Chara.CharacterApi.RegisteredHandlers">
            <summary>
            All currently registered kinds of <see cref="T:KKAPI.Chara.CharaCustomFunctionController"/> controllers.
            </summary>
        </member>
        <member name="T:KKAPI.Chara.CharacterApi.CopyExtendedDataFunc">
            <summary>
            Override to supply custom extended data copying logic.
            By default copies all data under <code>ExtendedDataId</code> by reference.
            </summary>
            <param name="dst">Copy current character's ext data to this character</param>
            <param name="src">Current character to copy the data from</param>
        </member>
        <member name="M:KKAPI.Chara.CharacterApi.FileControlToChaControl(AIChara.ChaFileControl)">
            <summary>
            Get ChaControl that is using the specified ChaFileControl.
            </summary>
        </member>
        <member name="M:KKAPI.Chara.CharacterApi.GetBehaviours(AIChara.ChaControl)">
            <summary>
            Get all extra behaviours for specified character. If null, returns extra behaviours for all characters.
            </summary>
        </member>
        <member name="M:KKAPI.Chara.CharacterApi.GetRegisteredBehaviour(System.String)">
            <summary>
            Get the first controller that was registered with the specified extendedDataId.
            </summary>
        </member>
        <member name="M:KKAPI.Chara.CharacterApi.GetRegisteredBehaviour(System.Type)">
            <summary>
            Get the first controller of the specified type that was registered. The type has to be an exact match.
            </summary>
        </member>
        <member name="M:KKAPI.Chara.CharacterApi.GetRegisteredBehaviour(System.Type,System.String)">
            <summary>
            Get the first controller of the specified type that was registered with the specified extendedDataId. The type has to be an exact match.
            </summary>
        </member>
        <member name="M:KKAPI.Chara.CharacterApi.RegisterExtraBehaviour``1(System.String)">
            <summary>
            Register new functionality that will be automatically added to all characters (where applicable).
            Offers easy API for saving and loading extended data, and for running logic to apply it to the characters.
            All necessary hooking and event subscribing is done for you. All you have to do is create a type
            that inherits from <code>CharaExtraBehaviour</code> (don't make instances, the API will make them for you).
            </summary>
            <typeparam name="T">Type with your custom logic to add to a character</typeparam>
            <param name="extendedDataId">Extended data ID used by this behaviour. Set to null if not used. Needed to copy the data in some situations.</param>
        </member>
        <member name="M:KKAPI.Chara.CharacterApi.RegisterExtraBehaviour``1(System.String,System.Int32)">
            <summary>
            Register new functionality that will be automatically added to all characters (where applicable).
            Offers easy API for saving and loading extended data, and for running logic to apply it to the characters.
            All necessary hooking and event subscribing is done for you. All you have to do is create a type
            that inherits from <code>CharaExtraBehaviour</code> (don't make instances, the API will make them for you).
            </summary>
            <typeparam name="T">Type with your custom logic to add to a character</typeparam>
            <param name="extendedDataId">Extended data ID used by this behaviour. Set to null if not used. Needed to copy the data in some situations.</param>
            <param name="priority">Default value is 1000, Decrease to increase priority or vice versa such on <see cref="M:KKAPI.Chara.CharaCustomFunctionController.OnReload(KKAPI.GameMode)"/> or related functions.</param>
        </member>
        <member name="M:KKAPI.Chara.CharacterApi.RegisterExtraBehaviour``1(System.String,KKAPI.Chara.CharacterApi.CopyExtendedDataFunc)">
            <summary>
            Register new functionality that will be automatically added to all characters (where applicable).
            Offers easy API for saving and loading extended data, and for running logic to apply it to the characters.
            All necessary hooking and event subscribing is done for you. All you have to do is create a type
            that inherits from <code>CharaExtraBehaviour</code> (don't make instances, the API will make them for you).
            </summary>
            <typeparam name="T">Type with your custom logic to add to a character</typeparam>
            <param name="extendedDataId">Extended data ID used by this behaviour. Set to null if not used.</param>
            <param name="customDataCopier">Override default extended data copy logic</param>
        </member>
        <member name="M:KKAPI.Chara.CharacterApi.RegisterExtraBehaviour``1(System.String,KKAPI.Chara.CharacterApi.CopyExtendedDataFunc,System.Int32)">
            <summary>
            Register new functionality that will be automatically added to all characters (where applicable).
            Offers easy API for saving and loading extended data, and for running logic to apply it to the characters.
            All necessary hooking and event subscribing is done for you. All you have to do is create a type
            that inherits from <code>CharaExtraBehaviour</code> (don't make instances, the API will make them for you).
            </summary>
            <typeparam name="T">Type with your custom logic to add to a character</typeparam>
            <param name="extendedDataId">Extended data ID used by this behaviour. Set to null if not used.</param>
            <param name="customDataCopier">Override default extended data copy logic</param>
            <param name="priority">Default value is 1000, Decrease to increase priority or vice versa such on <see cref="M:KKAPI.Chara.CharaCustomFunctionController.OnReload(KKAPI.GameMode)"/> or related functions.</param>
        </member>
        <member name="E:KKAPI.Chara.CharacterApi.CharacterReloaded">
            <summary>
            Fired after all CharaCustomFunctionController have updated.
            </summary>
        </member>
        <member name="E:KKAPI.Chara.CharacterApi.CoordinateLoaded">
            <summary>
            Fired after a coordinate card was loaded and all controllers were updated.
            Not filed if the coordinate file was not loaded into a character (so not during list updates). 
            </summary>
        </member>
        <member name="E:KKAPI.Chara.CharacterApi.CoordinateSaving">
            <summary>
            Fired just before a coordinate card is saved, but after all controllers wrote their data.
            </summary>
        </member>
        <member name="M:KKAPI.Chara.CharacterApi.Hooks.ChaFile_CopyChaFileHook(AIChara.ChaFile,AIChara.ChaFile)">
            <summary>
            Copy extended data when moving between class roster and main game data, and in free h
            (the character data gets transferred to predefined slots instead of creating new characters)
            </summary>
        </member>
        <member name="M:KKAPI.Chara.CharacterApi.Hooks.ChaControl_ChangeNowCoordinatePreHook(AIChara.ChaControl,AIChara.ChaFileCoordinate)">
            <summary>
            Copy extended data when current coordinate is about to be swapped. Should be a prefix to make sure it completes before any events are fired.
            Fixes losing ext data when character takes a bath, possibly in more instances.
            </summary>
        </member>
        <member name="M:KKAPI.Chara.CharacterApi.Hooks.ReloadAsyncPostHook(System.Boolean,System.Boolean,System.Boolean,System.Boolean,AIChara.ChaControl,System.Collections.IEnumerator@)">
            <summary>
            Needed for some edge cases, replacing characters in scene maker in EC
            </summary>
        </member>
        <member name="M:KKAPI.Chara.CharacterApi.Hooks.CharaData_InitializePost(ADV.CharaData)">
            <summary>
            Needed to update controllers after ADV scene finishes loading since characters get loaded async so other events fire too early
            </summary>
        </member>
        <member name="M:KKAPI.Chara.CharacterApi.Hooks.CharaData_InitializePost(AIChara.ChaControl,AIChara.ChaFileCoordinate,System.Boolean,System.Boolean)">
            <summary>
            Needed to catch coordinate updates in studio, h scene and other places
            </summary>
        </member>
        <member name="T:KKAPI.Chara.CharacterExtensions">
            <summary>
            Extensions for use with ChaControl, ChaFile and similar
            </summary>
        </member>
        <member name="M:KKAPI.Chara.CharacterExtensions.GetChaControl(AIChara.ChaFile)">
            <summary>
            Get ChaControl that is using this ChaFile if any exist.
            </summary>
        </member>
        <member name="T:KKAPI.Chara.CharacterExtensions.GetValueForInterface`2">
            <summary>
            Function for pulling data from a controller to be set to a maker control.
            </summary>
            <typeparam name="TController">Type of a custom character function controller.</typeparam>
            <typeparam name="TValue">Type of the value used by the control.</typeparam>
            <param name="controller">Controller to pull the value from.</param>
        </member>
        <member name="T:KKAPI.Chara.CharacterExtensions.SetValueToController`2">
            <summary>
            Function for pushing data from a control to be set in a controller.
            </summary>
            <typeparam name="TController">Type of a custom character function controller.</typeparam>
            <typeparam name="TValue">Type of the value used by the control.</typeparam>
            <param name="controller">Controller to push the value to.</param>
            <param name="value">Value to be pushed to the controller.</param>
        </member>
        <member name="M:KKAPI.Chara.CharacterExtensions.BindToFunctionController``2(KKAPI.Maker.UI.BaseEditableGuiEntry{``1},KKAPI.Chara.CharacterExtensions.GetValueForInterface{``0,``1},KKAPI.Chara.CharacterExtensions.SetValueToController{``0,``1})">
            <summary>
            Synchronize this maker control to the state of your custom <see cref="T:KKAPI.Chara.CharaCustomFunctionController"/>.
            When the control's value changes the change is sent to the controller, and when the character is reloaded 
            the change is automatically pulled from the controller into the control.
            </summary>
            <param name="guiEntry">Control to bind</param>
            <param name="getValue">Function that extracts the new value of the control from the controller.</param>
            <param name="setValue">Function that sets the new value from the control on the controller.</param>
            <typeparam name="TController">Type of the custom controller to bind the control to.</typeparam>
            <typeparam name="TValue">Type of the value used by the control.</typeparam>
            <exception cref="T:System.InvalidOperationException">The controller has not been registered in CharacterApi.</exception>
            <exception cref="T:System.ArgumentNullException">Any of the parameters is null.</exception>
        </member>
        <member name="T:KKAPI.Chara.CharaCustomFunctionController">
            <summary>
            Base type for custom character extensions.
            It provides many useful methods that abstract away the nasty hooks needed to figure out when
            a character is changed or how to save and load your custom data to the character card.
            
            This controller is a MonoBehaviour that is added to root gameObjects of ALL characters spawned into the game. 
            It's recommended to not use constructors, Awake or Start in controllers. Use <see cref="M:KKAPI.Chara.CharaCustomFunctionController.OnReload(KKAPI.GameMode,System.Boolean)"/> instead.
            </summary>
        </member>
        <member name="P:KKAPI.Chara.CharaCustomFunctionController.ChaControl">
            <summary>
            ChaControl of the character this controller is attached to. It's on the same gameObject as this controller.
            </summary>
        </member>
        <member name="P:KKAPI.Chara.CharaCustomFunctionController.ChaFileControl">
            <summary>
            ChaFile of the character this controller is attached to.
            </summary>
        </member>
        <member name="P:KKAPI.Chara.CharaCustomFunctionController.ExtendedDataId">
            <summary>
            ID used for extended data by this controller. It's set when registering the controller
            with <see cref="M:KKAPI.Chara.CharacterApi.RegisterExtraBehaviour``1(System.String)"/>
            </summary>
        </member>
        <member name="P:KKAPI.Chara.CharaCustomFunctionController.ControllerRegistration">
            <summary>
            Definition of this kind of function controllers.
            </summary>
        </member>
        <member name="P:KKAPI.Chara.CharaCustomFunctionController.Started">
            <summary>
            True if this controller has been initialized
            </summary>
        </member>
        <member name="M:KKAPI.Chara.CharaCustomFunctionController.GetExtendedData">
            <summary>
            Get extended data based on supplied ExtendedDataId. When in chara maker loads data from character that's being loaded. 
            This should be used inside the <see cref="M:KKAPI.Chara.CharaCustomFunctionController.OnReload(KKAPI.GameMode,System.Boolean)"/> event.
            Consider using one of the other "Get___ExtData" and "Set___ExtData" methods instead since they are more reliable and handle copying and transferring outfits and they conform to built in maker load toggles.
            </summary>
        </member>
        <member name="M:KKAPI.Chara.CharaCustomFunctionController.GetExtendedData(System.Boolean)">
            <summary>
            Get extended data of the current character by using the ID you specified when registering this controller.
            This should be used inside the <see cref="M:KKAPI.Chara.CharaCustomFunctionController.OnReload(KKAPI.GameMode,System.Boolean)"/> event.
            Consider using one of the other "Get___ExtData" and "Set___ExtData" methods instead since they are more reliable and handle copying and transferring outfits and they conform to built in maker load toggles.
            </summary>
            <param name="getFromLoadedChara">If true, when in chara maker load data from character that's being loaded. 
            When outside maker or false, always grab current character's data.</param>
        </member>
        <member name="M:KKAPI.Chara.CharaCustomFunctionController.SetExtendedData(ExtensibleSaveFormat.PluginData)">
            <summary>
            Save your custom data to the character card under the ID you specified when registering this controller.
            This should be used inside the <see cref="M:KKAPI.Chara.CharaCustomFunctionController.OnCardBeingSaved(KKAPI.GameMode)"/> event.
            Consider using one of the other "Get___ExtData" and "Set___ExtData" methods instead since they are more reliable and handle copying and transferring outfits and they conform to built in maker load toggles.
            </summary>
            <param name="data">Your custom data to be written to the character card. Can be null to remove the data.</param>
        </member>
        <member name="M:KKAPI.Chara.CharaCustomFunctionController.GetCoordinateExtendedData(AIChara.ChaFileCoordinate)">
            <summary>
            Get extended data of the specified coordinate by using the ID you specified when registering this controller.
            This should be used inside the <see cref="M:KKAPI.Chara.CharaCustomFunctionController.OnCoordinateBeingLoaded(AIChara.ChaFileCoordinate,System.Boolean)"/> event.
            Consider using one of the other "Get___ExtData" and "Set___ExtData" methods instead since they are more reliable and handle copying and transferring outfits and they conform to built in maker load toggles.
            </summary>
            <param name="coordinate">Coordinate you want to get the data from</param>
        </member>
        <member name="M:KKAPI.Chara.CharaCustomFunctionController.SetCoordinateExtendedData(AIChara.ChaFileCoordinate,ExtensibleSaveFormat.PluginData)">
            <summary>
            Set extended data to the specified coordinate by using the ID you specified when registering this controller.
            This should be used inside the <see cref="M:KKAPI.Chara.CharaCustomFunctionController.OnCoordinateBeingSaved(AIChara.ChaFileCoordinate)"/> event.
            Consider using one of the other "Get___ExtData" and "Set___ExtData" methods instead since they are more reliable and handle copying and transferring outfits and they conform to built in maker load toggles.
            </summary>
            <param name="coordinate">Coordinate you want to set the data to</param>
            <param name="data">Your custom data to be saved to the coordinate card</param>
        </member>
        <member name="M:KKAPI.Chara.CharaCustomFunctionController.OnCardBeingSaved(KKAPI.GameMode)">
            <summary>
            Fired when the character information is being saved.
            It handles all types of saving (to character card, to a scene etc.)
            Write any of your extended data in this method by using <see cref="M:KKAPI.Chara.CharaCustomFunctionController.SetExtendedData(ExtensibleSaveFormat.PluginData)"/>.
            Avoid reusing old PluginData since we might no longer be pointed to the same character.
            </summary>
        </member>
        <member name="M:KKAPI.Chara.CharaCustomFunctionController.OnReload(KKAPI.GameMode,System.Boolean)">
            <summary>
            OnReload is fired whenever the character's state needs to be updated.
            This might be beacuse the character was just loaded into the game, 
            was replaced with a different character, etc.
            Use this method instead of Awake and Start. It will always get called
            before other methods, but after the character is in a usable state.
            WARNING: Make sure to completely reset your state in this method!
                     Assume that all of your variables are no longer valid!
            </summary>
            <param name="currentGameMode">Game mode we are currently in</param>
            <param name="maintainState">If true, the current state should be preserved.
            Do not load new extended data, instead reuse what you currently have or do nothing.</param>
        </member>
        <member name="M:KKAPI.Chara.CharaCustomFunctionController.OnReload(KKAPI.GameMode)">
            <summary>
            OnReload is fired whenever the character's state needs to be updated.
            This might be beacuse the character was just loaded into the game, 
            was replaced with a different character, etc.
            Use this method instead of Awake and Start. It will always get called
            before other methods, but after the character is in a usable state.
            WARNING: Make sure to completely reset your state in this method!
                     Assume that all of your variables are no longer valid!
            WARNING: Will not get fired if disabled in <see cref="P:KKAPI.Chara.CharacterApi.RegisteredHandlers"/>, 
            use overloads with maintainState parameter in that case.
            </summary>
            <param name="currentGameMode">Game mode we are currently in</param>
        </member>
        <member name="M:KKAPI.Chara.CharaCustomFunctionController.OnCoordinateBeingSaved(AIChara.ChaFileCoordinate)">
            <summary>
            Fired just before current coordinate is saved to a coordinate card. Use <see cref="M:KKAPI.Chara.CharaCustomFunctionController.SetCoordinateExtendedData(AIChara.ChaFileCoordinate,ExtensibleSaveFormat.PluginData)"/> to save data to it. 
            You might need to wait for the next frame with <see cref="M:UnityEngine.MonoBehaviour.StartCoroutine(System.Collections.IEnumerator)"/> before handling this.
            </summary>
        </member>
        <member name="M:KKAPI.Chara.CharaCustomFunctionController.OnCoordinateBeingLoaded(AIChara.ChaFileCoordinate,System.Boolean)">
            <summary>
            Fired just after loading a coordinate card into the current coordinate slot.
            Use <see cref="M:KKAPI.Chara.CharaCustomFunctionController.GetCoordinateExtendedData(AIChara.ChaFileCoordinate)"/> to get save data of the loaded coordinate.
            </summary>
            <param name="coordinate">Coordinate being currently loaded.</param>
            <param name="maintainState">If true, the current state should be preserved.
            Do not load new extended data, instead reuse what you currently have or do nothing.</param>
        </member>
        <member name="M:KKAPI.Chara.CharaCustomFunctionController.OnCoordinateBeingLoaded(AIChara.ChaFileCoordinate)">
            <summary>
            Fired just after loading a coordinate card into the current coordinate slot.
            Use <see cref="M:KKAPI.Chara.CharaCustomFunctionController.GetCoordinateExtendedData(AIChara.ChaFileCoordinate)"/> to get save data of the loaded coordinate.
            Will not get fired if disabled in <see cref="P:KKAPI.Chara.CharacterApi.RegisteredHandlers"/>, 
            use overloads with maintainState parameter in that case.
            </summary>
            <param name="coordinate">Coordinate being currently loaded.</param>
        </member>
        <member name="M:KKAPI.Chara.CharaCustomFunctionController.Update">
            <summary>
            Warning: When overriding make sure to call the base method at the end of your logic!
            </summary>
        </member>
        <member name="M:KKAPI.Chara.CharaCustomFunctionController.OnDestroy">
            <summary>
            Warning: When overriding make sure to call the base method at the end of your logic!
            </summary>
        </member>
        <member name="M:KKAPI.Chara.CharaCustomFunctionController.OnEnable">
            <summary>
            Warning: When overriding make sure to call the base method at the end of your logic!
            </summary>
        </member>
        <member name="M:KKAPI.Chara.CharaCustomFunctionController.Awake">
            <summary>
            Warning: When overriding make sure to call the base method at the end of your logic!
            </summary>
        </member>
        <member name="M:KKAPI.Chara.CharaCustomFunctionController.Start">
            <summary>
            Warning: When overriding make sure to call the base method at the end of your logic!
            </summary>
        </member>
        <member name="M:KKAPI.Chara.CharaCustomFunctionController.GetClothesExtData(System.Int32)">
            <summary>
            Get extended data for specific clothes.
            Do not store this data because it might change without notice, for example when clothing is copied. Always call Get at the point where you need the data, not earlier.
            If you change any of the data, remember to call the corresponding Set method or the change might not be saved.
            This data is saved alongside game data, which means it is automatically copied and moved as necessary.
            If no extended data of this plugin was set yet, this method will return null.
            In maker, you can update controls that use this data in the <see cref="E:KKAPI.Maker.MakerAPI.ReloadCustomInterface"/> event.
            </summary>
            <param name="coordinateId">The coordinate number to open extened data for if the game supports multiple coords (0-indexed). -1 will use the current coordinate.</param>
        </member>
        <member name="M:KKAPI.Chara.CharaCustomFunctionController.GetAccessoryExtData(System.Int32,System.Int32)">
            <summary>
            Get extended data for a specific accessory.
            Do not store this data because it might change without notice, for example when clothing is copied. Always call Get at the point where you need the data, not earlier.
            If you change any of the data, remember to call the corresponding Set method or the change might not be saved.
            This data is saved alongside game data, which means it is automatically copied and moved as necessary.
            If no extended data of this plugin was set yet, this method will return null.
            In maker, you can update controls that use this data in the <see cref="E:KKAPI.Maker.MakerAPI.ReloadCustomInterface"/> event.
            </summary>
            <param name="accessoryPartId">The accessory part number to open extened data for (0-indexed).</param>
            <param name="coordinateId">The coordinate number to open extened data for if the game supports multiple coords (0-indexed). -1 will use the current coordinate.</param>
        </member>
        <member name="M:KKAPI.Chara.CharaCustomFunctionController.GetBodyExtData">
            <summary>
            Get extended data for character's body (body sliders, tattoos).
            Do not store this data because it might change without notice, for example when clothing is copied. Always call Get at the point where you need the data, not earlier.
            If you change any of the data, remember to call the corresponding Set method or the change might not be saved.
            This data is saved alongside game data, which means it is automatically copied and moved as necessary.
            If no extended data of this plugin was set yet, this method will return null.
            In maker, you can update controls that use this data in the <see cref="E:KKAPI.Maker.MakerAPI.ReloadCustomInterface"/> event.
            </summary>
        </member>
        <member name="M:KKAPI.Chara.CharaCustomFunctionController.GetFaceExtData">
            <summary>
            Get extended data for character's face (face sliders, eye settings).
            Do not store this data because it might change without notice, for example when clothing is copied. Always call Get at the point where you need the data, not earlier.
            If you change any of the data, remember to call the corresponding Set method or the change might not be saved.
            This data is saved alongside game data, which means it is automatically copied and moved as necessary.
            If no extended data of this plugin was set yet, this method will return null.
            In maker, you can update controls that use this data in the <see cref="E:KKAPI.Maker.MakerAPI.ReloadCustomInterface"/> event.
            </summary>
        </member>
        <member name="M:KKAPI.Chara.CharaCustomFunctionController.GetParameterExtData">
            <summary>
            Get extended data for character's parameters (personality, preferences, traits).
            Do not store this data because it might change without notice, for example when clothing is copied. Always call Get at the point where you need the data, not earlier.
            If you change any of the data, remember to call the corresponding Set method or the change might not be saved.
            This data is saved alongside game data, which means it is automatically copied and moved as necessary.
            If no extended data of this plugin was set yet, this method will return null.
            In maker, you can update controls that use this data in the <see cref="E:KKAPI.Maker.MakerAPI.ReloadCustomInterface"/> event.
            </summary>
        </member>
        <member name="M:KKAPI.Chara.CharaCustomFunctionController.SetClothesExtData(ExtensibleSaveFormat.PluginData,System.Int32)">
            <summary>
            Set extended data for specific clothes.
            Always call Set right after changing any of the data, or the change might not be saved if the data is changed for whatever reason (clothing change, reload, etc.)
            This data is saved alongside game data, which means it is automatically copied and moved as necessary.
            </summary>
            <param name="data">Extended data to save.</param>
            <param name="coordinateId">The coordinate number to open extened data for if the game supports multiple coords (0-indexed). -1 will use the current coordinate.</param>
        </member>
        <member name="M:KKAPI.Chara.CharaCustomFunctionController.SetAccessoryExtData(ExtensibleSaveFormat.PluginData,System.Int32,System.Int32)">
            <summary>
            Set extended data for a specific accessory.
            Always call Set right after changing any of the data, or the change might not be saved if the data is changed for whatever reason (clothing change, reload, etc.)
            This data is saved alongside game data, which means it is automatically copied and moved as necessary.
            </summary>
            <param name="data">Extended data to save.</param>
            <param name="accessoryPartId">The accessory part number to open extened data for (0-indexed).</param>
            <param name="coordinateId">The coordinate number to open extened data for if the game supports multiple coords (0-indexed). -1 will use the current coordinate.</param>
        </member>
        <member name="M:KKAPI.Chara.CharaCustomFunctionController.SetBodyExtData(ExtensibleSaveFormat.PluginData)">
            <summary>
            Set extended data for character's body (body sliders, tattoos).
            Always call Set right after changing any of the data, or the change might not be saved if the data is changed for whatever reason (clothing change, reload, etc.)
            This data is saved alongside game data, which means it is automatically copied and moved as necessary.
            </summary>
            <param name="data">Extended data to save.</param>
        </member>
        <member name="M:KKAPI.Chara.CharaCustomFunctionController.SetFaceExtData(ExtensibleSaveFormat.PluginData)">
            <summary>
            Set extended data for character's face (face sliders, eye settings).
            Always call Set right after changing any of the data, or the change might not be saved if the data is changed for whatever reason (clothing change, reload, etc.)
            This data is saved alongside game data, which means it is automatically copied and moved as necessary.
            </summary>
            <param name="data">Extended data to save.</param>
        </member>
        <member name="M:KKAPI.Chara.CharaCustomFunctionController.SetParameterExtData(ExtensibleSaveFormat.PluginData)">
            <summary>
            Set extended data for character's parameters (personality, preferences, traits).
            Always call Set right after changing any of the data, or the change might not be saved if the data is changed for whatever reason (clothing change, reload, etc.)
            This data is saved alongside game data, which means it is automatically copied and moved as necessary.
            </summary>
            <param name="data">Extended data to save.</param>
        </member>
        <member name="T:KKAPI.Chara.CharaReloadEventArgs">
            <summary>
            Event arguments used by character reload events
            </summary>
        </member>
        <member name="P:KKAPI.Chara.CharaReloadEventArgs.ReloadedCharacter">
            <summary>
            Can be null when all characters in a scene are reloaded
            </summary>
        </member>
        <member name="T:KKAPI.Chara.CoordinateEventArgs">
            <summary>
            Fired in events that deal with coordinate cards
            </summary>
        </member>
        <member name="P:KKAPI.Chara.CoordinateEventArgs.Character">
            <summary>
            Character the coordinate was loaded to
            </summary>
        </member>
        <member name="P:KKAPI.Chara.CoordinateEventArgs.LoadedCoordinate">
            <summary>
            The loaded coordinate
            </summary>
        </member>
        <member name="M:KKAPI.Chara.CoordinateEventArgs.GetCoordinateExtData">
            <summary>
            Get all exrtended data assigned to this coordinate card
            </summary>
        </member>
        <member name="M:KKAPI.Chara.CoordinateEventArgs.SetCoordinateExtData(System.String,ExtensibleSaveFormat.PluginData)">
            <summary>
            Set extended data for this coordinate card
            </summary>
            <param name="dataId">Key to save the data under (usually plugin GUID)</param>
            <param name="data">Data to set</param>
        </member>
        <member name="T:KKAPI.GameMode">
            <summary>
            Current gameplay mode the game is in
            </summary>
        </member>
        <member name="F:KKAPI.GameMode.Unknown">
            <summary>
            Anywhere else, including main menu
            </summary>
        </member>
        <member name="F:KKAPI.GameMode.Maker">
            <summary>
            Inside character maker (can be started from main menu or from class roster)
            </summary>
        </member>
        <member name="F:KKAPI.GameMode.Studio">
            <summary>
            Anywhere inside CharaStudio.exe
            </summary>
        </member>
        <member name="F:KKAPI.GameMode.MainGame">
            <summary>
            Anywhere inside the main game.
            Includes everything after starting a new game from title screen and after loading a saved game.
            This means this includes story scenes, night menu, roaming around and h scenes inside story mode.
            This does not hoverwer include the character maker launched from within the class menu.
            </summary>
        </member>
        <member name="T:KKAPI.Maker.CharacterLoadFlags">
            <summary>
            Specifies which parts of the character will be loaded when loading a card in character maker.
            (It's the toggles at the bottom of load window) Only includes stock toggles.
            </summary>
        </member>
        <member name="T:KKAPI.Maker.CoordinateLoadFlags">
            <summary>
            Specifies which parts of the coordinate will be loaded when loading a clothing card in character maker.
            </summary>
        </member>
        <member name="P:KKAPI.Maker.ChaFileLoadedEventArgs.LoadedChaFile">
            <summary>
            Use this to get extended data on the character
            </summary>
        </member>
        <member name="T:KKAPI.Maker.RegisterCustomControlsEvent">
            <summary>
            Event fired when character maker is starting and plugins are given an opportunity to register custom controls
            </summary>
        </member>
        <member name="M:KKAPI.Maker.RegisterCustomControlsEvent.AddControl``1(``0)">
            <summary>
            Add custom controls. If you want to use custom sub categories, register them by calling AddSubCategory.
            </summary>
        </member>
        <member name="M:KKAPI.Maker.RegisterCustomControlsEvent.AddSidebarControl``1(``0)">
            <summary>
            Add a control to the right sidebar in chara maker (the "Control Panel" where you set eye blinking, mouth expressions etc.)
            </summary>
        </member>
        <member name="M:KKAPI.Maker.RegisterCustomControlsEvent.AddLoadToggle(KKAPI.Maker.UI.MakerLoadToggle)">
            <summary>
            Add a toggle to the bottom of the "Load character" window that allows for partial loading of characters.
            </summary>
        </member>
        <member name="M:KKAPI.Maker.RegisterCustomControlsEvent.AddCoordinateLoadToggle(KKAPI.Maker.UI.MakerCoordinateLoadToggle)">
            <summary>
            Add a toggle to the bottom of the "Load coordinate/clothes" window that allows for partial loading of coordinate cards.
            </summary>
        </member>
        <member name="T:KKAPI.Maker.RegisterSubCategoriesEvent">
            <summary>
            Event fired when character maker is starting and plugins are given an opportunity to register custom categories and controls
            </summary>
        </member>
        <member name="M:KKAPI.Maker.RegisterSubCategoriesEvent.AddSubCategory(KKAPI.Maker.MakerCategory)">
            <summary>
            Add custom sub categories. They need to be added before maker starts loading,
            or in the RegisterCustomSubCategories event.
            </summary>
        </member>
        <member name="T:KKAPI.Maker.MakerAPI">
            <summary>
            Provides a way to add custom items to the in-game Character Maker, and gives useful methods for interfacing with the maker.
            </summary>
        </member>
        <member name="M:KKAPI.Maker.MakerAPI.AddControl``1(``0)">
            <summary>
            Add custom controls. If you want to use custom sub categories, register them by calling AddSubCategory.
            </summary>
        </member>
        <member name="M:KKAPI.Maker.MakerAPI.AddSubCategory(KKAPI.Maker.MakerCategory)">
            <summary>
            Add custom sub categories. They need to be added before maker starts loading,
            or in the <see cref="E:KKAPI.Maker.MakerAPI.RegisterCustomSubCategories"/> event.
            </summary>
        </member>
        <member name="M:KKAPI.Maker.MakerAPI.AddSidebarControl``1(``0)">
            <summary>
            Add a control to the right sidebar in chara maker (the "Control Panel" where you set eye blinking, mouth expressions etc.)
            </summary>
        </member>
        <member name="M:KKAPI.Maker.MakerAPI.AddAccessoryWindowControl``1(``0)">
            <summary>
            Add a control to the accessory selection and settings window.
            For editable controls that depend on the selected accessory use <see cref="M:KKAPI.Maker.MakerAPI.AddEditableAccessoryWindowControl``2(``0)"/>.
            </summary>
        </member>
        <member name="M:KKAPI.Maker.MakerAPI.AddEditableAccessoryWindowControl``2(``0)">
            <summary>
            Add a control to the accessory selection and settings window. The control is wrapped to properly respond to changes in selected accessory slot (has unique values for each slot).
            </summary>
        </member>
        <member name="M:KKAPI.Maker.MakerAPI.GetMakerSex">
            <summary>
            0 is male, 1 is female
            </summary>
        </member>
        <member name="M:KKAPI.Maker.MakerAPI.GetMakerBase">
            <summary>
            Returns current maker logic instance.
            Same as <see cref="P:Singleton`1.Instance"/>
            </summary>
        </member>
        <member name="M:KKAPI.Maker.MakerAPI.GetCharacterControl">
            <summary>
            Get the ChaControl of the character serving as a preview in character maker.
            Outside of character maker and early on in maker load process this returns null.
            </summary>
        </member>
        <member name="E:KKAPI.Maker.MakerAPI.RegisterCustomSubCategories">
            <summary>
            This event is fired every time the character maker is being loaded, near the very beginning.
            This is the only chance to add custom sub categories. Custom controls can be added now on later in <see cref="E:KKAPI.Maker.MakerAPI.MakerBaseLoaded"/>.
            Warning: All custom subcategories and custom controls are cleared on maker exit and need to be re-added on next maker start.
            It's recommended to completely clear your GUI state in <see cref="E:KKAPI.Maker.MakerAPI.MakerExiting"/> in preparation for loading into maker again.
            </summary>
        </member>
        <member name="E:KKAPI.Maker.MakerAPI.MakerStartedLoading">
            <summary>
            Early in the process of maker loading. Most game components are initialized and had their Start methods ran.
            Warning: Some components and objects might not be loaded or initialized yet, especially if they are mods.
            Warning: All custom subcategories and custom controls are cleared on maker exit and need to be re-added on next maker
            start.
            </summary>
        </member>
        <member name="E:KKAPI.Maker.MakerAPI.MakerBaseLoaded">
            <summary>
            Maker is fully loaded. Use to load mods that rely on something that is loaded late, else use MakerStartedLoading.
            This is the last chance to add custom controls!
            Warning: All custom subcategories and custom controls are cleared on maker exit and need to be re-added on next maker
            start.
            </summary>
        </member>
        <member name="E:KKAPI.Maker.MakerAPI.MakerFinishedLoading">
            <summary>
            Maker is fully loaded and the user has control.
            Warning: Avoid loading mods or doing anything heavy in this event.
            </summary>
        </member>
        <member name="E:KKAPI.Maker.MakerAPI.MakerExiting">
            <summary>
            Fired after the user exits the maker. Use this to clean up any references and resources.
            You want to return to the state you were in before maker was loaded.
            </summary>
        </member>
        <member name="P:KKAPI.Maker.MakerAPI.CharaListIsLoading">
            <summary>
            Use to avoid unnecessary processing cards when they are loaded to the character list.
            For example, don't load extended data for these characters since it's never used.
            </summary>
        </member>
        <member name="P:KKAPI.Maker.MakerAPI.LastLoadedChaFile">
            <summary>
            ChaFile of the character currently opened in maker. Do not use to save extended data, or it will be lost when saving the card.
            Use ChaFile from <code>ExtendedSave.CardBeingSaved</code> event to save extended data instead.
            </summary>
        </member>
        <member name="E:KKAPI.Maker.MakerAPI.ChaFileLoaded">
            <summary>
            Fired when the current ChaFile in maker is being changed by loading other cards or coordinates.
            This event is only fired when inside the character maker.
            
            You might need to wait for the next frame with <see cref="M:UnityEngine.MonoBehaviour.StartCoroutine(System.Collections.IEnumerator)"/> before handling this.
            </summary>
        </member>
        <member name="E:KKAPI.Maker.MakerAPI.ReloadCustomInterface">
            <summary>
            Fired after character or coordinate is loaded in maker, after all controllers had their events fired.
            This event is only fired when inside the character maker. Use this to update values of custom controls.
            EventArgs can be either <see cref="T:KKAPI.Chara.CharaReloadEventArgs"/> or <see cref="T:KKAPI.Chara.CoordinateEventArgs"/> depending on why the reload happened.
            </summary>
        </member>
        <member name="E:KKAPI.Maker.MakerAPI.InsideMakerChanged">
            <summary>
            Firen whenever <see cref="P:KKAPI.Maker.MakerAPI.InsideMaker"/> changes. This is the earliest event fired when user starts the character maker.
            </summary>
        </member>
        <member name="P:KKAPI.Maker.MakerAPI.InsideMaker">
            <summary>
            The maker scene is currently loaded. It might still be loading!
            </summary>
        </member>
        <member name="P:KKAPI.Maker.MakerAPI.InsideAndLoaded">
            <summary>
            Maker is fully loaded and running
            </summary>
        </member>
        <member name="M:KKAPI.Maker.MakerAPI.GetCharacterLoadFlags">
            <summary>
            Get values of the default partial load checkboxes present at the bottom of the 
            character load window (load face, body, hair, parameters, clothes).
            Returns null if the values could not be collected (safe to assume it's the same as being enabled).
            </summary>
        </member>
        <member name="M:KKAPI.Maker.MakerAPI.GetCoordinateLoadFlags">
            <summary>
            Get which parts of the coordinate will be loaded when loading a clothing card in character maker.
            Returns null if the values could not be collected (safe to assume it's the same as being enabled).
            </summary>
        </member>
        <member name="M:KKAPI.Maker.MakerAPI.IsInterfaceVisible">
            <summary>
            Check if maker interface is currently visible and not obscured by settings screen or other things.
            Useful for knowing when to display OnGui mod windows in maker.
            </summary>
        </member>
        <member name="M:KKAPI.Maker.MakerAPI.Hooks.CustomClothesWindow_ButtonClickedHook(CharaCustom.CustomClothesWindow)">
            <summary>
            Store which coord load button was pressed before running the stock game code
            </summary>
        </member>
        <member name="T:KKAPI.Maker.MakerCategory">
            <summary>
            Specifies a category inside character maker.
            </summary>
        </member>
        <member name="M:KKAPI.Maker.MakerCategory.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:KKAPI.Maker.MakerCategory.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:KKAPI.Maker.MakerCategory.#ctor(System.String,System.String,System.Int32,System.String)">
            <summary>
            Make a new custom subcategory. 
            </summary>
        </member>
        <member name="P:KKAPI.Maker.MakerCategory.CategoryName">
            <summary>
            Main category gameObject name. Main categories are the square buttons at the top-left edge of the screen.
            They contain multiple subcategories (tabs on the left edge of the screen).
            </summary>
        </member>
        <member name="P:KKAPI.Maker.MakerCategory.SubCategoryName">
            <summary>
            Sub category gameObject name. Sub categories are the named tabs on the left edge of the screen.
            They contain the actual controls (inside the window on the right of the tabs).
            </summary>
        </member>
        <member name="P:KKAPI.Maker.MakerCategory.Position">
            <summary>
            Numeric position of the subcategory.
            When making new subcategories you can set this value to be in-between stock subcategories.
            </summary>
        </member>
        <member name="P:KKAPI.Maker.MakerCategory.DisplayName">
            <summary>
            The text displayed on the subcategory tab on the left edge of the screen.
            </summary>
        </member>
        <member name="M:KKAPI.Maker.MakerCategory.ToString">
            <summary>
            Get combined name for logging etc.
            </summary>
        </member>
        <member name="T:KKAPI.Maker.UI.BaseEditableGuiEntry`1">
            <summary>
            Base of custom controls that have a value that can be changed and watched for changes.
            </summary>
        </member>
        <member name="M:KKAPI.Maker.UI.BaseEditableGuiEntry`1.#ctor(KKAPI.Maker.MakerCategory,`0,BepInEx.BaseUnityPlugin)">
            <inheritdoc />
        </member>
        <member name="P:KKAPI.Maker.UI.BaseEditableGuiEntry`1.Value">
            <summary>
            Buttons 1, 2, 3 are values 0, 1, 2
            </summary>
        </member>
        <member name="P:KKAPI.Maker.UI.BaseEditableGuiEntry`1.ValueChanged">
            <summary>
            Fired every time the value is changed, and once when the control is created.
            Buttons 1, 2, 3 are values 0, 1, 2
            </summary>
        </member>
        <member name="P:KKAPI.Maker.UI.BaseEditableGuiEntry`1.BufferedValueChanged">
            <summary>
            Use to get value changes for controls. Fired by external value set and by SetNewValue.
            </summary>
        </member>
        <member name="M:KKAPI.Maker.UI.BaseEditableGuiEntry`1.SetValue(`0)">
            <summary>
            Set the new value and trigger the <see cref="P:KKAPI.Maker.UI.BaseEditableGuiEntry`1.ValueChanged"/> event if the control has been created and the value actually changed.
            </summary>
            <param name="newValue">Value to set</param>
        </member>
        <member name="M:KKAPI.Maker.UI.BaseEditableGuiEntry`1.SetValue(`0,System.Boolean)">
            <summary>
            Set the new value and optionally trigger the <see cref="P:KKAPI.Maker.UI.BaseEditableGuiEntry`1.ValueChanged"/> event if the control has been created.
            </summary>
            <param name="newValue">Value to set</param>
            <param name="fireEvents">Fire the <see cref="P:KKAPI.Maker.UI.BaseEditableGuiEntry`1.ValueChanged"/> event if the value actually changed.</param>
        </member>
        <member name="M:KKAPI.Maker.UI.BaseEditableGuiEntry`1.Dispose">
            <inheritdoc />
        </member>
        <member name="T:KKAPI.Maker.UI.BaseGuiEntry">
            <summary>
            Base of all custom character maker controls.
            </summary>
        </member>
        <member name="F:KKAPI.Maker.UI.BaseGuiEntry.GuiApiNameAppendix">
            <summary>
            Added to the end of most custom controls to mark them as being created by this API.
            </summary>
        </member>
        <member name="M:KKAPI.Maker.UI.BaseGuiEntry.#ctor(KKAPI.Maker.MakerCategory,BepInEx.BaseUnityPlugin)">
            <summary>
            Create a new custom control
            </summary>
            <param name="category">Category the control will be created under</param>
            <param name="owner">Plugin that owns the control</param>
        </member>
        <member name="P:KKAPI.Maker.UI.BaseGuiEntry.Category">
            <summary>
            Category and subcategory that this control is inside of.
            </summary>
        </member>
        <member name="P:KKAPI.Maker.UI.BaseGuiEntry.GuiCacheTransfrom">
            <summary>
            Parent transform that holds temporary gui entries used to instantiate custom controls.
            </summary>
        </member>
        <member name="M:KKAPI.Maker.UI.BaseGuiEntry.GetExistingControl(System.String,System.String)">
            <summary>
            Find first control of this name under the specified category transform
            </summary>
        </member>
        <member name="M:KKAPI.Maker.UI.BaseGuiEntry.Initialize">
            <summary>
            Called before OnCreateControl to setup the object before instantiating the control.
            </summary>
        </member>
        <member name="M:KKAPI.Maker.UI.BaseGuiEntry.Dispose">
            <summary>
            Remove the control. Called when maker is quitting.
            </summary>
            <inheritdoc />
        </member>
        <member name="P:KKAPI.Maker.UI.BaseGuiEntry.IsDisposed">
            <summary>
            If true, the control has been disposed and can no longer be used, likely because the character maker exited.
            A new control has to be created to be used again.
            </summary>
        </member>
        <member name="M:KKAPI.Maker.UI.BaseGuiEntry.OnCreateControl(UnityEngine.Transform)">
            <summary>
            Used by the API to actually create the custom control.
            Should return main GameObject of the control
            </summary>
        </member>
        <member name="P:KKAPI.Maker.UI.BaseGuiEntry.TextColor">
            <summary>
            Text color of the control's description text (usually on the left).
            Can only set this before the control is created.
            </summary>
        </member>
        <member name="P:KKAPI.Maker.UI.BaseGuiEntry.Owner">
            <summary>
            The plugin that owns this custom control.
            </summary>
        </member>
        <member name="P:KKAPI.Maker.UI.BaseGuiEntry.GroupingID">
            <summary>
            ID used when grouping controls into groups separated by separators. Groups are sorted alphabetically.
            If multiple plugins use the same group, the controls are placed together.
            By default each plugin has its own group. Set to null to use the "misc" group.
            </summary>
        </member>
        <member name="P:KKAPI.Maker.UI.BaseGuiEntry.AutomateVisible">
            <summary>
            If true, Api automates showing and hiding of accessory controls
            </summary>
        </member>
        <member name="P:KKAPI.Maker.UI.BaseGuiEntry.Visible">
            <summary>
            The control is visible to the user (usually the same as it's GameObject being active).
            </summary>
        </member>
        <member name="P:KKAPI.Maker.UI.BaseGuiEntry.ControlObjects">
            <summary>
            GameObject(s) of the control. Populated once instantiated.
            Contains 1 item in most cases, can contain multiple in case of accessory window controls.
            </summary>
        </member>
        <member name="P:KKAPI.Maker.UI.BaseGuiEntry.ControlObject">
            <summary>
            GameObject of the control. Populated once instantiated.
            If there are multiple objects, returns one of them. Use <see cref="P:KKAPI.Maker.UI.BaseGuiEntry.ControlObjects"/> in that case.
            </summary>
        </member>
        <member name="P:KKAPI.Maker.UI.BaseGuiEntry.Exists">
            <summary>
            True if the control is currently instantiated in the scene
            </summary>
        </member>
        <member name="T:KKAPI.Maker.UI.Sidebar.ISidebarControl">
            <summary>
            Marks the control as being intended for use on Control Panel sidebar in chara maker
            </summary>
        </member>
        <member name="T:KKAPI.Maker.UI.Sidebar.SidebarToggle">
            <summary>
            A toggle to be used in the right "Control Panel" sidebar in character maker.
            The space is limited so use sparingly.
            </summary>
        </member>
        <member name="M:KKAPI.Maker.UI.Sidebar.SidebarToggle.#ctor(System.String,System.Boolean,BepInEx.BaseUnityPlugin)">
            <inheritdoc />
        </member>
        <member name="M:KKAPI.Maker.UI.Sidebar.SidebarToggle.Initialize">
            <inheritdoc />
        </member>
        <member name="M:KKAPI.Maker.UI.Sidebar.SidebarToggle.OnCreateControl(UnityEngine.Transform)">
            <inheritdoc />
        </member>
        <member name="P:KKAPI.Maker.UI.Sidebar.SidebarToggle.Text">
            <summary>
            Text displayed next to the checkbox
            </summary>
        </member>
        <member name="T:KKAPI.Maker.UI.MakerButton">
            <summary>
            Custom control that draws a simple blue button.
            </summary>
        </member>
        <member name="M:KKAPI.Maker.UI.MakerButton.#ctor(System.String,KKAPI.Maker.MakerCategory,BepInEx.BaseUnityPlugin)">
            <summary>
            Create a new custom control. Create and register it in <see cref="E:KKAPI.Maker.MakerAPI.RegisterCustomSubCategories"/>.
            </summary>
            <param name="text">Text displayed on the button</param>
            <param name="category">Category the control will be created under</param>
            <param name="owner">Plugin that owns the control</param>
        </member>
        <member name="P:KKAPI.Maker.UI.MakerButton.OnClick">
            <summary>
            Fired when user clicks on the button
            </summary>
        </member>
        <member name="P:KKAPI.Maker.UI.MakerButton.Text">
            <summary>
            Text displayed on the button
            </summary>
        </member>
        <member name="M:KKAPI.Maker.UI.MakerButton.Initialize">
            <inheritdoc />
        </member>
        <member name="M:KKAPI.Maker.UI.MakerButton.Dispose">
            <inheritdoc />
        </member>
        <member name="M:KKAPI.Maker.UI.MakerButton.OnCreateControl(UnityEngine.Transform)">
            <inheritdoc />
        </member>
        <member name="T:KKAPI.Maker.UI.MakerColor">
            <summary>
            Control that allows user to change a <see cref="T:UnityEngine.Color"/> in a separate color selector window
            </summary>
        </member>
        <member name="M:KKAPI.Maker.UI.MakerColor.#ctor(System.String,System.Boolean,KKAPI.Maker.MakerCategory,UnityEngine.Color,BepInEx.BaseUnityPlugin)">
            <summary>
            Create a new custom control. Create and register it in <see cref="E:KKAPI.Maker.MakerAPI.RegisterCustomSubCategories"/>.
            </summary>
            <param name="settingName">Text displayed next to the control</param>
            <param name="useAlpha">
            If true, the color selector will allow the user to change alpha of the color.
            If false, no color slider is shown and alpha is always 1f.
            </param>
            <param name="category">Category the control will be created under</param>
            <param name="initialValue">Color set to the control when it is created</param>
            <param name="owner">Plugin that owns the control</param>
        </member>
        <member name="P:KKAPI.Maker.UI.MakerColor.SettingName">
            <summary>
            Name of the setting
            </summary>
        </member>
        <member name="P:KKAPI.Maker.UI.MakerColor.UseAlpha">
            <summary>
            If true, the color selector will allow the user to change alpha of the color.
            If false, no color slider is shown and alpha is always 1f.
            </summary>
        </member>
        <member name="M:KKAPI.Maker.UI.MakerColor.Initialize">
            <inheritdoc />
        </member>
        <member name="M:KKAPI.Maker.UI.MakerColor.OnCreateControl(UnityEngine.Transform)">
            <inheritdoc />
        </member>
        <member name="T:KKAPI.Maker.UI.MakerCoordinateLoadToggle">
            <summary>
            Adds a toggle to the bottom of the coordinate/clothes card load window in character maker.
            Use to allow user to not load data related to your mod.
            Use with <see cref="M:KKAPI.Maker.UI.MakerCoordinateLoadToggle.AddLoadToggle(KKAPI.Maker.UI.MakerCoordinateLoadToggle)"/>
            </summary>
        </member>
        <member name="M:KKAPI.Maker.UI.MakerCoordinateLoadToggle.#ctor(System.String,System.Boolean)">
            <summary>
            Create a new coordinate load toggle. Create and register it in <see cref="E:KKAPI.Maker.MakerAPI.RegisterCustomSubCategories"/> 
            with <see cref="M:KKAPI.Maker.RegisterCustomControlsEvent.AddCoordinateLoadToggle(KKAPI.Maker.UI.MakerCoordinateLoadToggle)"/>.
            </summary>
            <param name="text">Text displayed next to the checkbox</param>
            <param name="initialValue">Initial value of the toggle</param>
        </member>
        <member name="P:KKAPI.Maker.UI.MakerCoordinateLoadToggle.Text">
            <summary>
            Text displayed next to the toggle
            </summary>
        </member>
        <member name="P:KKAPI.Maker.UI.MakerCoordinateLoadToggle.AnyEnabled">
            <summary>
            Check if any of the custom toggles are checked
            </summary>
        </member>
        <member name="M:KKAPI.Maker.UI.MakerCoordinateLoadToggle.OnCreateControl(UnityEngine.Transform)">
            <inheritdoc />
        </member>
        <member name="M:KKAPI.Maker.UI.MakerCoordinateLoadToggle.Initialize">
            <inheritdoc />
        </member>
        <member name="T:KKAPI.Maker.UI.MakerDropdown">
            <summary>
            Custom control that draws a dropdown list
            </summary>
        </member>
        <member name="M:KKAPI.Maker.UI.MakerDropdown.#ctor(System.String,System.String[],KKAPI.Maker.MakerCategory,System.Int32,BepInEx.BaseUnityPlugin)">
            <summary>
            Create a new custom control. Create and register it in <see cref="E:KKAPI.Maker.MakerAPI.RegisterCustomSubCategories"/>.
            </summary>
            <param name="settingName">Text displayed next to the dropdown</param>
            <param name="options">Items for the dropdown menu</param>
            <param name="category">Category the control will be created under</param>
            <param name="initialValue">Initially selected item in the dropdown menu</param>
            <param name="owner">Plugin that owns the control</param>
        </member>
        <member name="P:KKAPI.Maker.UI.MakerDropdown.Options">
            <summary>
            List of all options in the dropdown
            </summary>
        </member>
        <member name="P:KKAPI.Maker.UI.MakerDropdown.SettingName">
            <summary>
            Name displayed next to the dropdown
            </summary>
        </member>
        <member name="M:KKAPI.Maker.UI.MakerDropdown.Initialize">
            <inheritdoc />
        </member>
        <member name="M:KKAPI.Maker.UI.MakerDropdown.OnCreateControl(UnityEngine.Transform)">
            <inheritdoc />
        </member>
        <member name="T:KKAPI.Maker.UI.MakerImage">
            <summary>
            Custom control that displays a texture in a small preview thumbnail
            </summary>
        </member>
        <member name="P:KKAPI.Maker.UI.MakerImage.Texture">
            <summary>
            Texture to display in the preview
            </summary>
        </member>
        <member name="P:KKAPI.Maker.UI.MakerImage.Width">
            <summary>
            Width of the texture preview
            </summary>
        </member>
        <member name="P:KKAPI.Maker.UI.MakerImage.Height">
            <summary>
            Height of the texture preview
            </summary>
        </member>
        <member name="M:KKAPI.Maker.UI.MakerImage.#ctor(UnityEngine.Texture,KKAPI.Maker.MakerCategory,BepInEx.BaseUnityPlugin)">
            <summary>
            Create a new custom control. Create and register it in <see cref="E:KKAPI.Maker.MakerAPI.RegisterCustomSubCategories"/>.
            </summary>
            <param name="texture">Texture to be displayed in the image box. Can be null for empty.</param>
            <param name="category">Category the control will be created under</param>
            <param name="owner">Plugin that owns the control</param>
        </member>
        <member name="M:KKAPI.Maker.UI.MakerImage.Initialize">
            <inheritdoc />
        </member>
        <member name="M:KKAPI.Maker.UI.MakerImage.OnCreateControl(UnityEngine.Transform)">
            <inheritdoc />
        </member>
        <member name="T:KKAPI.Maker.UI.MakerLoadToggle">
            <summary>
            Adds a toggle to the bottom of the character card load window in character maker.
            Use to allow user to not load data related to your mod.
            Use with <see cref="M:KKAPI.Maker.UI.MakerLoadToggle.AddLoadToggle(KKAPI.Maker.UI.MakerLoadToggle)"/>
            </summary>
        </member>
        <member name="M:KKAPI.Maker.UI.MakerLoadToggle.#ctor(System.String,System.Boolean)">
            <summary>
            Create a new load toggle. Create and register it in <see cref="E:KKAPI.Maker.MakerAPI.RegisterCustomSubCategories"/> 
            with <see cref="M:KKAPI.Maker.RegisterCustomControlsEvent.AddLoadToggle(KKAPI.Maker.UI.MakerLoadToggle)"/>.
            </summary>
            <param name="text">Text displayed next to the checkbox</param>
            <param name="initialValue">Initial value of the toggle</param>
        </member>
        <member name="P:KKAPI.Maker.UI.MakerLoadToggle.Text">
            <summary>
            Text displayed next to the toggle
            </summary>
        </member>
        <member name="P:KKAPI.Maker.UI.MakerLoadToggle.AnyEnabled">
            <summary>
            Check if any of the custom toggles are checked
            </summary>
        </member>
        <member name="M:KKAPI.Maker.UI.MakerLoadToggle.OnCreateControl(UnityEngine.Transform)">
            <inheritdoc />
        </member>
        <member name="M:KKAPI.Maker.UI.MakerLoadToggle.Initialize">
            <inheritdoc />
        </member>
        <member name="T:KKAPI.Maker.UI.MakerRadioButtons">
            <summary>
            Custom control that displays multiple radio buttons
            </summary>
        </member>
        <member name="P:KKAPI.Maker.UI.MakerRadioButtons.Buttons">
            <summary>
            Objects of all of the radio buttons
            </summary>
        </member>
        <member name="M:KKAPI.Maker.UI.MakerRadioButtons.#ctor(KKAPI.Maker.MakerCategory,BepInEx.BaseUnityPlugin,System.String,System.String[])">
            <summary>
            Create a new custom control. Create and register it in <see cref="E:KKAPI.Maker.MakerAPI.RegisterCustomSubCategories"/>.
            </summary>
            <param name="settingName">Text displayed next to the buttons</param>
            <param name="category">Category the control will be created under</param>
            <param name="owner">Plugin that owns the control</param>
            <param name="buttons">Names of the radio buttons. Need at least 2 buttons.</param>
        </member>
        <member name="M:KKAPI.Maker.UI.MakerRadioButtons.#ctor(KKAPI.Maker.MakerCategory,BepInEx.BaseUnityPlugin,System.String,System.Int32,System.String[])">
            <summary>
            Create a new custom control. Create and register it in <see cref="E:KKAPI.Maker.MakerAPI.RegisterCustomSubCategories"/>.
            </summary>
            <param name="settingName">Text displayed next to the buttons</param>
            <param name="category">Category the control will be created under</param>
            <param name="owner">Plugin that owns the control</param>
            <param name="initialValue">Initial value of the control</param>
            <param name="buttons">Names of the radio buttons. Need at least 2 buttons.</param>
        </member>
        <member name="M:KKAPI.Maker.UI.MakerRadioButtons.Initialize">
            <inheritdoc />
        </member>
        <member name="M:KKAPI.Maker.UI.MakerRadioButtons.OnCreateControl(UnityEngine.Transform)">
            <inheritdoc />
        </member>
        <member name="T:KKAPI.Maker.UI.MakerSeparator">
            <summary>
            Custom control that draws a simple horizontal separator
            </summary>
        </member>
        <member name="M:KKAPI.Maker.UI.MakerSeparator.OnCreateControl(UnityEngine.Transform)">
            <inheritdoc />
        </member>
        <member name="M:KKAPI.Maker.UI.MakerSeparator.Initialize">
            <inheritdoc />
        </member>
        <member name="M:KKAPI.Maker.UI.MakerSeparator.#ctor(KKAPI.Maker.MakerCategory,BepInEx.BaseUnityPlugin)">
            <summary>
            Create a new custom control. Create and register it in <see cref="E:KKAPI.Maker.MakerAPI.RegisterCustomSubCategories"/>.
            </summary>
            <param name="category">Category the control will be created under</param>
            <param name="owner">Plugin that owns the control</param>
        </member>
        <member name="T:KKAPI.Maker.UI.MakerSlider">
            <summary>
            Custom control that draws a slider and a text box (both are used to edit the same value)
            </summary>
        </member>
        <member name="P:KKAPI.Maker.UI.MakerSlider.DefaultValue">
            <summary>
            Value used when user presses the Reset button.
            </summary>
        </member>
        <member name="M:KKAPI.Maker.UI.MakerSlider.#ctor(KKAPI.Maker.MakerCategory,System.String,System.Single,System.Single,System.Single,BepInEx.BaseUnityPlugin)">
            <summary>
            Create a new custom control. Create and register it in <see cref="E:KKAPI.Maker.MakerAPI.RegisterCustomSubCategories"/>.
            </summary>
            <param name="settingName">Text displayed next to the slider</param>
            <param name="category">Category the control will be created under</param>
            <param name="owner">Plugin that owns the control</param>
            <param name="minValue">Lowest allowed value (inclusive)</param>
            <param name="maxValue">Highest allowed value (inclusive)</param>
            <param name="defaultValue">Value the slider will be set to after creation</param>
        </member>
        <member name="P:KKAPI.Maker.UI.MakerSlider.StringToValue">
            <summary>
            Custom converter from text in the textbox to the slider value.
            If not set, <code>float.Parse(txt) / 100f</code> is used.
            </summary>
        </member>
        <member name="P:KKAPI.Maker.UI.MakerSlider.ValueToString">
            <summary>
            Custom converter from the slider value to what's displayed in the textbox.
            If not set, <code>Mathf.RoundToInt(f * 100).ToString()</code> is used.
            </summary>
        </member>
        <member name="M:KKAPI.Maker.UI.MakerSlider.Initialize">
            <inheritdoc />
        </member>
        <member name="M:KKAPI.Maker.UI.MakerSlider.OnCreateControl(UnityEngine.Transform)">
            <inheritdoc />
        </member>
        <member name="T:KKAPI.Maker.UI.MakerText">
            <summary>
            Custom control that displays a simple text
            </summary>
        </member>
        <member name="P:KKAPI.Maker.UI.MakerText.ExplanationGray">
            <summary>
            Light gray color best used for text explaining another setting
            </summary>
        </member>
        <member name="M:KKAPI.Maker.UI.MakerText.#ctor(System.String,KKAPI.Maker.MakerCategory,BepInEx.BaseUnityPlugin)">
            <summary>
            Create a new custom control. Create and register it in <see cref="E:KKAPI.Maker.MakerAPI.RegisterCustomSubCategories"/>.
            </summary>
            <param name="text">Displayed text</param>
            <param name="category">Category the control will be created under</param>
            <param name="owner">Plugin that owns the control</param>
        </member>
        <member name="P:KKAPI.Maker.UI.MakerText.Text">
            <summary>
            Displayed text
            </summary>
        </member>
        <member name="M:KKAPI.Maker.UI.MakerText.Initialize">
            <inheritdoc />
        </member>
        <member name="M:KKAPI.Maker.UI.MakerText.OnCreateControl(UnityEngine.Transform)">
            <inheritdoc />
        </member>
        <member name="T:KKAPI.Maker.UI.MakerTextbox">
            <summary>
            Custom control that draws a single-line text box.
            </summary>
        </member>
        <member name="P:KKAPI.Maker.UI.MakerTextbox.DefaultValue">
            <summary>
            Value used when user presses the Reset button.
            </summary>
        </member>
        <member name="P:KKAPI.Maker.UI.MakerTextbox.ContentType">
            <summary>
            Type of content filtering to do on the input.
            </summary>
        </member>
        <member name="P:KKAPI.Maker.UI.MakerTextbox.CharacterLimit">
            <summary>
            Maximum number of characters, about 22 are visible at once.
            </summary>
        </member>
        <member name="M:KKAPI.Maker.UI.MakerTextbox.#ctor(KKAPI.Maker.MakerCategory,System.String,System.String,BepInEx.BaseUnityPlugin)">
            <summary>
            Create a new custom control. Create and register it in <see cref="E:KKAPI.Maker.MakerAPI.RegisterCustomSubCategories"/>.
            </summary>
            <param name="settingName">Text displayed next to the slider</param>
            <param name="category">Category the control will be created under</param>
            <param name="owner">Plugin that owns the control</param>
            <param name="defaultValue">Value the textbox will be set to after creation</param>
        </member>
        <member name="M:KKAPI.Maker.UI.MakerTextbox.Initialize">
            <inheritdoc />
        </member>
        <member name="M:KKAPI.Maker.UI.MakerTextbox.OnCreateControl(UnityEngine.Transform)">
            <inheritdoc />
        </member>
        <member name="T:KKAPI.Maker.UI.MakerToggle">
            <summary>
            Custom control that displays a toggle
            </summary>
        </member>
        <member name="M:KKAPI.Maker.UI.MakerToggle.#ctor(KKAPI.Maker.MakerCategory,System.String,BepInEx.BaseUnityPlugin)">
            <summary>
            Create a new custom control. Create and register it in <see cref="E:KKAPI.Maker.MakerAPI.RegisterCustomSubCategories"/>.
            </summary>
            <param name="displayName">Text shown next to the checkbox</param>
            <param name="category">Category the control will be created under</param>
            <param name="owner">Plugin that owns the control</param>
        </member>
        <member name="M:KKAPI.Maker.UI.MakerToggle.#ctor(KKAPI.Maker.MakerCategory,System.String,System.Boolean,BepInEx.BaseUnityPlugin)">
            <summary>
            Create a new custom control. Create and register it in <see cref="E:KKAPI.Maker.MakerAPI.RegisterCustomSubCategories"/>.
            </summary>
            <param name="displayName">Text shown next to the checkbox</param>
            <param name="category">Category the control will be created under</param>
            <param name="initialValue">Initial value of the toggle</param>
            <param name="owner">Plugin that owns the control</param>
        </member>
        <member name="P:KKAPI.Maker.UI.MakerToggle.DisplayName">
            <summary>
            Text shown next to the checkbox
            </summary>
        </member>
        <member name="M:KKAPI.Maker.UI.MakerToggle.Initialize">
            <inheritdoc />
        </member>
        <member name="M:KKAPI.Maker.UI.MakerToggle.OnCreateControl(UnityEngine.Transform)">
            <inheritdoc />
        </member>
        <member name="T:KKAPI.Maker.AccessoriesApi">
            <summary>
            Collection of methods useful for interfacing with character accessories. Has methods both for chara maker and
            everywhere else.
            Abstracts away MoreAccessories so you don't have to worry if it's installed or not.
            </summary>
        </member>
        <member name="P:KKAPI.Maker.AccessoriesApi.AccessoryCanvasVisible">
            <summary>
            Returns true if the accessory tab in maker is currently selected.
            If you want to know if the user can actually see the tab on the screen check <see cref="M:KKAPI.Maker.MakerAPI.IsInterfaceVisible"/>.
            </summary>
        </member>
        <member name="P:KKAPI.Maker.AccessoriesApi.MoreAccessoriesInstalled">
            <summary>
            True if the MoreAccessories mod is installed.
            Avoid relying on this and instead use other methods in this class since they will handle this for you.
            </summary>
        </member>
        <member name="P:KKAPI.Maker.AccessoriesApi.SelectedMakerAccSlot">
            <summary>
            Get the index of the currently selected accessory slot under Accessories group in Chara Maker.
            If none are selected or chara maker is not opened, returns -1. 0-indexed.
            Use <see cref="E:KKAPI.Maker.AccessoriesApi.SelectedMakerAccSlotChanged"/> to get notified when the selected slot changes.
            </summary>
        </member>
        <member name="E:KKAPI.Maker.AccessoriesApi.SelectedMakerAccSlotChanged">
            <summary>
            Fires whenever the index of the currently selected accessory slot under Accessories group in Chara Maker is changed.
            This happens when user click on another slot.
            </summary>
        </member>
        <member name="E:KKAPI.Maker.AccessoriesApi.AccessoryKindChanged">
            <summary>
            Fires when user selects a different accessory in the accessory window.
            </summary>
        </member>
        <member name="E:KKAPI.Maker.AccessoriesApi.AccessoryTransferred">
            <summary>
            Fires after user copies an accessory within a single coordinate by using the Transfer window.
            </summary>
        </member>
        <member name="M:KKAPI.Maker.AccessoriesApi.GetAccessoryObjects(AIChara.ChaControl)">
            <summary>
            Get a list of all accessory objects for this character.
            If an accessory slot exists but has no accessory in it, it will appear as null on the list.
            </summary>
        </member>
        <member name="M:KKAPI.Maker.AccessoriesApi.GetAccessoryObject(AIChara.ChaControl,System.Int32)">
            <summary>
            Get accessory objects of specified index for this character.
            null will be returned if an accessory slot exists but has no accessory in it, or if the slot doesn't exist.
            If index is below 0 or the character is null an exception will be thrown.
            </summary>
        </member>
        <member name="M:KKAPI.Maker.AccessoriesApi.GetMakerAccessoryCount">
            <summary>
            Get count of the UI entries for accessories (accessory slots).
            Returns 0 outside of chara maker.
            </summary>
        </member>
        <member name="M:KKAPI.Maker.AccessoriesApi.GetMakerAccessoryPageObject(System.Int32)">
            <summary>
            Get the root gameobject of the maker UI page for the specified accessory.
            </summary>
            <param name="index">Index of the accessory to get the UI for. Use -1 to get the currently opened accessory page</param>
        </member>
        <member name="M:KKAPI.Maker.AccessoriesApi.GetOwningCharacter(UnityEngine.GameObject)">
            <summary>
            Get the character that owns this accessory
            </summary>
        </member>
        <member name="M:KKAPI.Maker.AccessoriesApi.GetAccessoryIndex(AIChara.ChaControl,UnityEngine.GameObject)">
            <summary>
            Get index of this accessory, or -1 if it doesn't exist for the specified character.
            </summary>
        </member>
        <member name="M:KKAPI.Maker.AccessoriesApi.GetAccessory(AIChara.ChaControl,System.Int32)">
            <summary>
            Get the accessory given a slot index.
            </summary>
        </member>
        <member name="M:KKAPI.Maker.AccessoriesApi.GetAccessoryIndex(AIChara.CmpAccessory)">
            <summary>
            Get slot index of his accessory, useful for referencing to the accesory in extended data.
            </summary>
        </member>
        <member name="M:KKAPI.Maker.AccessoriesApi.GetCvsAccessory">
            <summary>
            Get accessory UI entry in maker.
            Only works inside chara maker.
            </summary>
        </member>
        <member name="M:KKAPI.Maker.AccessoriesApi.GetPartsInfo(System.Int32)">
            <summary>
            Get accessory PartsInfo entry in maker.
            Only works inside chara maker.
            </summary>
        </member>
        <member name="M:KKAPI.Maker.AccessoriesApi.GetCvsAccessoryCount">
            <summary>
            Get count of the UI entries for accessories (accessory slots).
            Returns 0 outside of chara maker.
            </summary>
        </member>
        <member name="M:KKAPI.Maker.AccessoriesApi.GetOwningChaControl(AIChara.CmpAccessory)">
            <summary>
            Get the ChaControl that owns this accessory
            </summary>
        </member>
        <member name="T:KKAPI.Maker.AccessoryControlWrapper`2">
            <summary>
            A wrapper for custom controls used in accessory window (added by using <see cref="M:KKAPI.Maker.MakerAPI.AddAccessoryWindowControl``1(``0)"/>).
            It abstracts away switching between accessory slots and provides a simple list of values for each accessory.
            </summary>
            <typeparam name="T">Type of the control to be wrapped. The control has to be added by using <see cref="M:KKAPI.Maker.MakerAPI.AddAccessoryWindowControl``1(``0)"/> or results will be undefined.</typeparam>
            <typeparam name="TVal">Type of the control's value.</typeparam>
        </member>
        <member name="M:KKAPI.Maker.AccessoryControlWrapper`2.#ctor(`0)">
            <summary>
            Create a new wrapper.
            </summary>
            <param name="control">Control to be wrapped. The control has to be added by using <see cref="M:KKAPI.Maker.MakerAPI.AddAccessoryWindowControl``1(``0)"/> or results will be undefined.</param>
        </member>
        <member name="P:KKAPI.Maker.AccessoryControlWrapper`2.Control">
            <summary>
            The wrapped control.
            </summary>
        </member>
        <member name="M:KKAPI.Maker.AccessoryControlWrapper`2.GetValue(System.Int32)">
            <summary>
            Get value of the control for the specified accessory.
            </summary>
        </member>
        <member name="M:KKAPI.Maker.AccessoryControlWrapper`2.GetSelectedValue">
            <summary>
            Get value of the control for the currently selected accessory.
            </summary>
        </member>
        <member name="M:KKAPI.Maker.AccessoryControlWrapper`2.SetValue(System.Int32,`1)">
            <summary>
            Set value of the control for the specified accessory.
            </summary>
            <param name="accessoryIndex">Index of the accessory to set the value for</param>
            <param name="value">Value to set</param>
        </member>
        <member name="M:KKAPI.Maker.AccessoryControlWrapper`2.SetValue(System.Int32,`1,System.Boolean)">
            <summary>
            Set value of the control for the specified accessory.
            </summary>
            <param name="accessoryIndex">Index of the accessory to set the value for</param>
            <param name="value">Value to set</param>
            <param name="fireEvents">Fire the <see cref="E:KKAPI.Maker.AccessoryControlWrapper`2.ValueChanged"/> event if the value actually changed.</param>
        </member>
        <member name="M:KKAPI.Maker.AccessoryControlWrapper`2.SetSelectedValue(`1)">
            <summary>
            Set value of the control for the currently selected accessory.
            </summary>
            <param name="value">Value to set</param>
        </member>
        <member name="M:KKAPI.Maker.AccessoryControlWrapper`2.SetSelectedValue(`1,System.Boolean)">
            <summary>
            Set value of the control for the currently selected accessory.
            </summary>
            <param name="value">Value to set</param>
            <param name="fireEvents">Fire the <see cref="E:KKAPI.Maker.AccessoryControlWrapper`2.ValueChanged"/> event if the value actually changed.</param>
        </member>
        <member name="P:KKAPI.Maker.AccessoryControlWrapper`2.CurrentlySelectedIndex">
            <summary>
            Index of the currently selected accessory.
            </summary>
        </member>
        <member name="E:KKAPI.Maker.AccessoryControlWrapper`2.ValueChanged">
            <summary>
            Fired when the value of this control changes for any of the accessories.
            </summary>
        </member>
        <member name="E:KKAPI.Maker.AccessoryControlWrapper`2.VisibleIndexChanged">
            <summary>
            Fired when the currently visible accessory was changed by the user clicking on one of the slots.
            </summary>
        </member>
        <member name="E:KKAPI.Maker.AccessoryControlWrapper`2.AccessoryKindChanged">
            <summary>
            Fires when user selects a different accessory in the accessory window.
            </summary>
        </member>
        <member name="E:KKAPI.Maker.AccessoryControlWrapper`2.AccessoryTransferred">
            <summary>
            Fires after user copies an accessory within a single coordinate by using the Transfer window.
            </summary>
        </member>
        <member name="P:KKAPI.Maker.AccessoryControlWrapper`2.IsDisposed">
            <summary>
            If true, the control has been disposed and can no longer be used, likely because the character maker exited.
            A new control has to be created to be used again.
            </summary>
        </member>
        <member name="T:KKAPI.Maker.AccessorySlotEventArgs">
            <summary>
            Event args for events that are related to accessory slot indexes.
            </summary>
        </member>
        <member name="M:KKAPI.Maker.AccessorySlotEventArgs.#ctor(System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:KKAPI.Maker.AccessorySlotEventArgs.SlotIndex">
            <summary>
            Currently opened accessory slot index. 0-indexed.
            </summary>
        </member>
        <member name="P:KKAPI.Maker.AccessorySlotEventArgs.CvsAccessory">
            <summary>
            Get accessory UI entry in maker.
            </summary>
        </member>
        <member name="P:KKAPI.Maker.AccessorySlotEventArgs.AccessoryComponent">
            <summary>
            Get accessory component.
            </summary>
        </member>
        <member name="T:KKAPI.Maker.AccessoryTransferEventArgs">
            <summary>
            Event args for accessory transfer events.
            </summary>
        </member>
        <member name="M:KKAPI.Maker.AccessoryTransferEventArgs.#ctor(System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:KKAPI.Maker.AccessoryTransferEventArgs.SourceSlotIndex">
            <summary>
            Index of the source accessory.
            </summary>
        </member>
        <member name="P:KKAPI.Maker.AccessoryTransferEventArgs.DestinationSlotIndex">
            <summary>
            Index the source accessory is copied to.
            </summary>
        </member>
        <member name="T:KKAPI.Maker.AccessoryWindowControlValueChangedEventArgs`1">
            <summary>
            Event args used in <see cref="T:KKAPI.Maker.AccessoryControlWrapper`2"/>.
            </summary>
        </member>
        <member name="M:KKAPI.Maker.AccessoryWindowControlValueChangedEventArgs`1.#ctor(`0,System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:KKAPI.Maker.AccessoryWindowControlValueChangedEventArgs`1.NewValue">
            <summary>
            Newly assigned value.
            </summary>
        </member>
        <member name="P:KKAPI.Maker.AccessoryWindowControlValueChangedEventArgs`1.SlotIndex">
            <summary>
            Index of the accessory the value was assigned to.
            </summary>
        </member>
        <member name="T:KKAPI.Maker.MakerCardSave">
            <summary>
            API for modifying the process of saving cards in maker.
            </summary>
        </member>
        <member name="T:KKAPI.Maker.MakerCardSave.DirectoryPathModifier">
            <summary>
            Used for modifying card save paths. Parameter is the original path, return the changed path.
            </summary>
        </member>
        <member name="T:KKAPI.Maker.MakerCardSave.CardNameModifier">
            <summary>
            Used for modifying card file names. Parameter is the original name, return the changed name.
            </summary>
        </member>
        <member name="M:KKAPI.Maker.MakerCardSave.RegisterNewCardSavePathModifier(KKAPI.Maker.MakerCardSave.DirectoryPathModifier,KKAPI.Maker.MakerCardSave.CardNameModifier)">
            <summary>
            Add a function that can modify the path of the saved cards.
            Use sparingly and insert/replace parts of the path instead of overwriting the whole path to keep compatibility with other plugins.
            </summary>
            <param name="directoryPathModifier">Modifier for the directory the card is saved to. Set to null if no change is required.</param>
            <param name="filenameModifier">Modifier for the name the card file itself. Set to null if no change is required.</param>
        </member>
        <member name="T:KKAPI.Maker.MakerConstants">
            <summary>
            Useful values from the character maker. Mostly built-in categories for use with registering custom controls.
            </summary>
        </member>
        <member name="F:KKAPI.Maker.MakerConstants.DefaultControlTextColor">
            <summary>
            Default text color for maker controls.
            </summary>
        </member>
        <member name="M:KKAPI.Maker.MakerInterfaceCreator.AddMissingSubCategories(CharaCustom.CvsSelectWindow)">
            <summary>
            Needs to run before UI_ToggleGroupCtrl.Start of the category runs, or it won't get added properly
            </summary>
        </member>
        <member name="T:KKAPI.SceneApi">
            <summary>
            Game-agnostic version of Manager.Scene. It allows using the same code in all games without any #if directives.
            </summary>
        </member>
        <member name="M:KKAPI.SceneApi.GetAddSceneName">
            <summary>
            Get name of the currently loaded overlay scene (eg. exit game box, config, confirmation dialogs).
            </summary>
        </member>
        <member name="M:KKAPI.SceneApi.GetLoadSceneName">
            <summary>
            Get name of the currently loaded game scene (eg. maker, h, adv).
            </summary>
        </member>
        <member name="M:KKAPI.SceneApi.GetIsNowLoadingFade">
            <summary>
            True if loading screen is being displayed, or if screen is currently fading in or out.
            </summary>
        </member>
        <member name="M:KKAPI.SceneApi.GetIsNowLoading">
            <summary>
            True if loading screen is being displayed.
            </summary>
        </member>
        <member name="M:KKAPI.SceneApi.GetIsFadeNow">
            <summary>
            True if screen is currently fading in or out.
            </summary>
        </member>
        <member name="M:KKAPI.SceneApi.GetIsOverlap">
            <summary>
            True if a dialog box or some other overlapping menu is shown (e.g. exit dialog after pressing esc).
            </summary>
        </member>
        <member name="T:KKAPI.Utilities.ImguiComboBox">
            <summary>
            Dropdown control for use in GUILayout areas and windows. Keep the instance and call Show on it to draw it inside OnGUI.
            Remember to call `DrawDropdownIfOpen` at the very end of the OnGUI area/window to actually display the dropdown list if it's open.
            Only one dropdown list can be open globally. If a new dropdown is opened, all others are closed without changing the selected index.
            </summary>
        </member>
        <member name="M:KKAPI.Utilities.ImguiComboBox.Show(System.Int32,UnityEngine.GUIContent[],System.Int32,UnityEngine.GUIStyle)">
            <summary>
            Show a button that when clicked opens a dropdown list. Returns new index if user selected a different option, or the old index.
            Warning: The list itself is not drawn here, you have to call DrawDropdownIfOpen at the end of your GUILayout area/window.
            </summary>
            <param name="selectedIndex">Currently selected item from the content list. It will be shown on the button.</param>
            <param name="listContent">All items shown in the dropdown list when it is open.</param>
            <param name="windowYmax">How low the dropdown can reach. Used to prevent the dropdown from extending off-screen. Set it to the GUILayout.Window rect yMax value.</param>
            <param name="listStyle">Optional style of list buttons. By default the standard button style is used.</param>
        </member>
        <member name="M:KKAPI.Utilities.ImguiComboBox.Show(UnityEngine.GUIContent,System.Func{UnityEngine.GUIContent[]},System.Action{System.Int32},System.Int32,UnityEngine.GUIStyle)">
            <summary>
            Show a button that when clicked opens a dropdown list.
            Warning: The list itself is not drawn here, you have to call DrawDropdownIfOpen at the end of your GUILayout area/window.
            </summary>
            <param name="selectedContent">Content shown on the button. It will also be selected in the dropdown list if it exists.</param>
            <param name="getListContent">Called once to get the list contents when the button is clicked. It should return contents of the dropdown list, including <paramref name="selectedContent"/>.</param>
            <param name="onIndexChanged">Called when user selects a new item</param>
            <param name="windowYmax"></param>
            <param name="listStyle"></param>
        </member>
        <member name="M:KKAPI.Utilities.ImguiComboBox.DrawDropdownIfOpen">
            <summary>
            Draws the dropdown list on top of all other window controls if it is open.
            This should always be called at the very end of area/window that `Show` was called in.
            Returns true if the dropdown list was opened and subsequently drawn.
            </summary>
        </member>
        <member name="T:KKAPI.Utilities.ImguiWindow`1">
            <summary>
            Base class for IMGUI windows that are implemented as full MonoBehaviours.
            Instantiate to add the window, only one instance should ever exist.
            Turn drawing the window on and off by setting the enable property (off by default).
            </summary>
        </member>
        <member name="P:KKAPI.Utilities.ImguiWindow`1.Instance">
            <summary>
            Instance of the window. Null if none were created yet.
            </summary>
        </member>
        <member name="M:KKAPI.Utilities.ImguiWindow`1.#ctor">
            <summary>
            Base constructor
            </summary>
        </member>
        <member name="M:KKAPI.Utilities.ImguiWindow`1.OnGUI">
            <summary>
            Make sure to call base.OnGUI when overriding!
            </summary>
        </member>
        <member name="M:KKAPI.Utilities.ImguiWindow`1.GetDefaultWindowRect(UnityEngine.Rect)">
            <summary>
            Should return the initial desired size of the window, adjusted to fit inside the screen space.
            </summary>
        </member>
        <member name="M:KKAPI.Utilities.ImguiWindow`1.DrawContents">
            <summary>
            Draw contents of the IMGUI window (this is inside of the GUILayout.Window func).
            Use GUILayout instead of GUI, and expect the window size to change during runtime.
            </summary>
        </member>
        <member name="M:KKAPI.Utilities.ImguiWindow`1.OnEnable">
            <summary>
            Make sure to call base.OnEnable when overriding!
            </summary>
        </member>
        <member name="M:KKAPI.Utilities.ImguiWindow`1.ResetWindowRect">
            <summary>
            Reset the window rect (position and size) to its default value.
            </summary>
        </member>
        <member name="P:KKAPI.Utilities.ImguiWindow`1.Title">
            <summary>
            Title of the window.
            </summary>
        </member>
        <member name="P:KKAPI.Utilities.ImguiWindow`1.WindowId">
            <summary>
            ID of the window, set to a random number by default.
            </summary>
        </member>
        <member name="P:KKAPI.Utilities.ImguiWindow`1.WindowRect">
            <summary>
            Position and size of the window.
            </summary>
        </member>
        <member name="P:KKAPI.Utilities.ImguiWindow`1.MinimumSize">
            <summary>
            Minimum size of the window.
            </summary>
        </member>
        <member name="T:KKAPI.Utilities.TimelineCompatibility">
            <summary>
            API for adding Timeline support to other plugins. Support is done by registering interpolable models that appear in the interpolables list in Timeline.
            </summary>
            <remarks>
            Always call IsTimelineAvailable first and only call other methods in this class if it returns <c>true</c>.
            <example>
            Example usage (assuming using a KKAPI chara function controller):
            <code>
            if (TimelineCompatibility.IsTimelineAvailable())
            {
                TimelineCompatibility.AddCharaFunctionInterpolable&lt;int, PregnancyCharaController&gt;(
                    GUID, "week", "Pregnancy week",
                    (oci, parameter, leftValue, rightValue, factor) => parameter.Data.Week = Mathf.RoundToInt(Mathf.LerpUnclamped(leftValue, rightValue, factor)),
                    null,
                    (oci, parameter) => parameter.Data.Week);
            }
            </code>
            You can use other methods in this class if you are not working with function controllers.
            </example>
            This API probably won't work if called from a thread.
            </remarks>
        </member>
        <member name="T:KKAPI.Utilities.TimelineCompatibility.InterpolableCharaDelegate`2">
            <inheritdoc cref="T:KKAPI.Utilities.TimelineCompatibility.InterpolableDelegate`2"/>
        </member>
        <member name="T:KKAPI.Utilities.TimelineCompatibility.InterpolableDelegate">
            <inheritdoc cref="T:KKAPI.Utilities.TimelineCompatibility.InterpolableDelegate`2"/>
        </member>
        <member name="T:KKAPI.Utilities.TimelineCompatibility.InterpolableDelegate`2">
            <summary>
            Action that applies a value interpolated by Timeline.
            </summary>
            <remarks>
            <example>Example callback that changes a transform's position:<code>((Transform)parameter).localPosition = Vector3.LerpUnclamped((Vector3)leftValue, (Vector3)rightValue, factor);</code></example>
            If <typeparamref name="TValue"/> is a <c>bool</c> then simply use the <paramref name="leftValue"/> directly.
            </remarks>
            <typeparam name="TValue">The type of the value.</typeparam>
            <typeparam name="TParameter">The type of the parameter.</typeparam>
            <param name="oci">Target studio object.</param>
            <param name="parameter">Parameter that's being worked on.</param>
            <param name="leftValue">Value of the interpolable on the left side of current playback position.</param>
            <param name="rightValue">Value of the interpolable on the right side of current playback position.</param>
            <param name="factor">
            Point between <paramref name="leftValue"/> and <paramref name="rightValue"/>we are currently at (percentage in 0-1 range).
            Use with <see cref="M:UnityEngine.Mathf.LerpUnclamped(System.Single,System.Single,System.Single)"/> and similar methods to get the final value. Make sure to use Unclamped lerp methods unless you need the percentage to be in the 0-1 range.
            </param>
        </member>
        <member name="M:KKAPI.Utilities.TimelineCompatibility.IsTimelineAvailable">
            <summary>
            Check if Timeline is loaded and available to be used. If false, other methods in this class will throw.
            This must be called after all plugins finish loadeding (in Start/Main instead of constructors/Awake).
            It always returns false outside of studio.
            </summary>
        </member>
        <member name="M:KKAPI.Utilities.TimelineCompatibility.GetPlaybackTime">
            <summary>
            Gets current playback location in seconds.
            </summary>
        </member>
        <member name="M:KKAPI.Utilities.TimelineCompatibility.GetDuration">
            <summary>
            Gets the total duration in seconds.
            </summary>
        </member>
        <member name="M:KKAPI.Utilities.TimelineCompatibility.GetIsPlaying">
            <summary>
            Check if timeline is currently playing.
            </summary>
        </member>
        <member name="M:KKAPI.Utilities.TimelineCompatibility.Play">
            <summary>
            Play/Pause timeline playback (toggles between the two).
            </summary>
        </member>
        <member name="M:KKAPI.Utilities.TimelineCompatibility.AddInterpolableModelDynamic``2(System.String,System.String,System.String,KKAPI.Utilities.TimelineCompatibility.InterpolableDelegate{``0,``1},KKAPI.Utilities.TimelineCompatibility.InterpolableDelegate{``0,``1},System.Func{Studio.ObjectCtrlInfo,System.Boolean},System.Func{Studio.ObjectCtrlInfo,``1,``0},System.Func{``1,System.Xml.XmlNode,``0},System.Action{``1,System.Xml.XmlTextWriter,``0},System.Func{Studio.ObjectCtrlInfo,``1},System.Func{Studio.ObjectCtrlInfo,System.Xml.XmlNode,``1},System.Action{Studio.ObjectCtrlInfo,System.Xml.XmlTextWriter,``1},System.Func{Studio.ObjectCtrlInfo,``1,``0,``0,System.Boolean},System.Boolean,System.Func{System.String,Studio.ObjectCtrlInfo,``1,System.String},System.Func{Studio.ObjectCtrlInfo,``1,System.Boolean})">
            <summary>
            Adds an interpolableModel with a dynamic parameter to the available interpolables list. This interpolable can then be instantiated by the user by adding a keyframe.
            The dynamic parameter means that every time user creates this interpolable, you can provide a different parameter - this allows having multiple instances of this interpolable for a single studio object. The instances are differentiated by the parameter, which must be unique and have a unique hash code (if the parameters have identical hashes they are treated as the same thing).
            Examples where this is useful: editing individual character bone positions/scales, changing color of individual accessories.
            If you want to make a global interpolable you can use AddInterpolableModelStatic instead.
            Try to keep the callbacks as light and self-contained as possible since they can be called on every frame during playback or UI usage (except the xml callbacks). If you need to find some object to later use in the callbacks, consider using it as the parameter (that way it will only be computed once and you can use it later for free, just make sure the parameter is always the same since if you have different parameters will create separate instances).
            </summary>
            <remarks>
            Use cases:
            <list type="bullet">
            <item>To make a global interpolable (affects overall studio state) set <paramref name="useOciInHash"/> to false and don't provide unique parameters (or any parameters at all).</item>
            <item>To make a single interpolable per studio object (e.g. changing a character's hair color) set <paramref name="useOciInHash"/> to true and don't provide unique parameters (or any parameters at all).</item>
            <item>To make multiple interpolables per studio object (e.g. changing color of different clothing items) set <paramref name="useOciInHash"/> to true and provide unique parameters that represent the exact thing that is being changed.
            How this works: When user adds a new interpolable then</item>
            </list>
            Execution order:
            <list type="number">
            <item>InterpolableModel is created and added</item>
            <item><paramref name="isCompatibleWithTarget"/> is called when any studio object is selected (null if nothing is selected)</item>
            <item>When user adds a new keyframe for this interpolable, <paramref name="isCompatibleWithTarget"/> is called to determine if it can be created.</item>
            <item><paramref name="getParameter"/> and <paramref name="getValue"/> are called in that order. The new interpolable's hash is computed based on <paramref name="useOciInHash"/> and the returned parameter.</item>
            <item><paramref name="shouldShow"/> and <paramref name="getFinalName"/> are called after creating the interpolable and every time the user does something that should update the UI.</item>
            <item>If playing, <paramref name="interpolateBefore"/> and <paramref name="interpolateAfter"/> are called in that order. <paramref name="checkIntegrity"/> called before each of them to determine if the callbacks should be ran. Put logic that affects the studio object here (e.g. changing bone position).</item>
            <item>When saving the studio scene or just the timeline data, <paramref name="writeParameterToXml"/> and <paramref name="writeValueToXml"/> are called as necessary.</item>
            </list>
            </remarks>
            <typeparam name="TValue">The type of the value.</typeparam>
            <typeparam name="TParameter">The type of the parameter.</typeparam>
            <param name="owner">Display name of the owner of this interpolable. It's used both in the UI and for serialization. Must not change between game restarts.</param>
            <param name="id">ID of this interpolable used for serialization. Must be unique and not change between game restarts.</param>
            <param name="name">Display name shown in the available interpolable list. It's also used for names of the created interpolable instances if <paramref name="getFinalName"/> is not provided.</param>
            <param name="interpolateBefore">
            Action to do around the start of the frame (inside Update).
            Make changes to the object state here (e.g. change transform position).
            <example><code>((Transform)parameter).localPosition = Vector3.LerpUnclamped((Vector3)leftValue, (Vector3)rightValue, factor);</code></example>
            </param>
            <param name="interpolateAfter">
            Action to do around the end of the frame (inside LateUpdate).
            Make changes to the object state here (e.g. change transform position) if you need to do them inside LateUpdate.
            <example><code>((Transform)parameter).localPosition = Vector3.LerpUnclamped((Vector3)leftValue, (Vector3)rightValue, factor);</code></example>
            </param>
            <param name="isCompatibleWithTarget">
            Func that should return true if this interpolable can be used on the given studio object.
            This is called before all other callbacks and before the interpolable is actually created.
            <example><code>oci is OCIChar</code></example>
            </param>
            <param name="getValue">
            Get the current value of this interpolable.
            If loading timeline data, <paramref name="readValueFromXml"/> is used instead.
            <example><code>((Transform)parameter).localPosition</code></example>
            </param>
            <param name="readValueFromXml">
            Deserialize a value of this interpolable from XML.
            It's optional as long as you use a common simple value type like <see cref="T:System.Single"/> or <see cref="T:UnityEngine.Vector3"/> that has a deserializer available.
            <example><code>node.ReadVector3("value")</code></example>
            </param>
            <param name="writeValueToXml">
            Serialize a value of this interpolable to XML.
            It's optional as long as you use a common simple value type like <see cref="T:System.Single"/> or <see cref="T:UnityEngine.Vector3"/> that has a serializer available.
            <example><code>writer.WriteValue("value", (Vector3)obj)</code></example>
            </param>
            <param name="getParameter">
            Get object/data to apply changes to.
            The main use of parameters is when you can have multiple instances of this interpolable on a single studio object - you can then use parameters to differentiate individual parts, e.g. bones.
            For example you can use the transform that this interporable will affect (set its position etc.) as a parameter - that way you can have separate interpolables for different transforms of the same studio object.
            This parameter will be passed to other callbacks, and it will be serialized and deserialized when saving/loading timeline data (serializing it is optional but without serializing the parameter you will lose it after scene reload).
            If you are using parameters, make sure to implement <paramref name="getFinalName"/> as well - it's used to give different names to interpolables based on the parameter (e.g. transform name).
            Note: Everything related to parameters is optional and can be skipped if you don't need multiple instances of the interpolable on a single studio object.
            Parameters should be hashable (hash should be stable during the game session).
            <example><code>((OCIChar)oci).GetChaControl().transform.Find("someBone")</code></example>
            </param>
            <param name="readParameterFromXml">
            Deserialize a parameter previosuly saved with <paramref name="writeParameterToXml"/>.
            <example><code>return oci.guideObject.transformTarget.transform.Find(node.Attributes["parameter"].Value));</code></example>
            </param>
            <param name="writeParameterToXml">
            Serialize the parameter to store it inside timeline data.
            It will be later deserialized with <paramref name="readParameterFromXml"/>.
            For example if you use a <see cref="T:UnityEngine.Transform"/> for your parameter, you can write its path or name if its unique, and then search for it when deserializing.
            <example><code>writer.WriteAttributeString("parameter", ((Transform)parameter).name);</code></example>
            </param>
            <param name="checkIntegrity">
            Check if the parameter and data are valid and can be interpolated.
            If false is returned, <paramref name="interpolateBefore"/> and <paramref name="interpolateAfter"/> are not called (everything else is unaffected).
            </param>
            <param name="useOciInHash">If true, assign this interpolable to a specific studio object. If false, the interpolable is global and most callbacks will be given <c>null</c> as the <see cref="T:Studio.ObjectCtrlInfo"/> argument.</param>
            <param name="getFinalName">Get a name for a newly created interpolable instance. Use to differentiate different instances of the same interpolable. If <c>null</c>, <paramref name="name"/> is used.</param>
            <param name="shouldShow">Check if this interpolable <b>instance</b> should apper in the list given the current state. This is called on every list refresh <b>after</b> the interpolable is created.</param>
        </member>
        <member name="M:KKAPI.Utilities.TimelineCompatibility.AddInterpolableModelDynamic(System.String,System.String,System.String,KKAPI.Utilities.TimelineCompatibility.InterpolableDelegate,KKAPI.Utilities.TimelineCompatibility.InterpolableDelegate,System.Func{Studio.ObjectCtrlInfo,System.Boolean},System.Func{Studio.ObjectCtrlInfo,System.Object,System.Object},System.Func{System.Object,System.Xml.XmlNode,System.Object},System.Action{System.Object,System.Xml.XmlTextWriter,System.Object},System.Func{Studio.ObjectCtrlInfo,System.Object},System.Func{Studio.ObjectCtrlInfo,System.Xml.XmlNode,System.Object},System.Action{Studio.ObjectCtrlInfo,System.Xml.XmlTextWriter,System.Object},System.Func{Studio.ObjectCtrlInfo,System.Object,System.Object,System.Object,System.Boolean},System.Boolean,System.Func{System.String,Studio.ObjectCtrlInfo,System.Object,System.String},System.Func{Studio.ObjectCtrlInfo,System.Object,System.Boolean})">
            <inheritdoc cref="M:KKAPI.Utilities.TimelineCompatibility.AddInterpolableModelDynamic``2(System.String,System.String,System.String,KKAPI.Utilities.TimelineCompatibility.InterpolableDelegate{``0,``1},KKAPI.Utilities.TimelineCompatibility.InterpolableDelegate{``0,``1},System.Func{Studio.ObjectCtrlInfo,System.Boolean},System.Func{Studio.ObjectCtrlInfo,``1,``0},System.Func{``1,System.Xml.XmlNode,``0},System.Action{``1,System.Xml.XmlTextWriter,``0},System.Func{Studio.ObjectCtrlInfo,``1},System.Func{Studio.ObjectCtrlInfo,System.Xml.XmlNode,``1},System.Action{Studio.ObjectCtrlInfo,System.Xml.XmlTextWriter,``1},System.Func{Studio.ObjectCtrlInfo,``1,``0,``0,System.Boolean},System.Boolean,System.Func{System.String,Studio.ObjectCtrlInfo,``1,System.String},System.Func{Studio.ObjectCtrlInfo,``1,System.Boolean})"/>
        </member>
        <member name="M:KKAPI.Utilities.TimelineCompatibility.AddInterpolableModelStatic``2(System.String,System.String,``1,System.String,KKAPI.Utilities.TimelineCompatibility.InterpolableDelegate{``0,``1},KKAPI.Utilities.TimelineCompatibility.InterpolableDelegate{``0,``1},System.Func{Studio.ObjectCtrlInfo,System.Boolean},System.Func{Studio.ObjectCtrlInfo,``1,``0},System.Func{``1,System.Xml.XmlNode,``0},System.Action{``1,System.Xml.XmlTextWriter,``0},System.Func{Studio.ObjectCtrlInfo,System.Xml.XmlNode,``1},System.Action{Studio.ObjectCtrlInfo,System.Xml.XmlTextWriter,``1},System.Func{Studio.ObjectCtrlInfo,``1,``0,``0,System.Boolean},System.Boolean,System.Func{System.String,Studio.ObjectCtrlInfo,``1,System.String},System.Func{Studio.ObjectCtrlInfo,``1,System.Boolean})">
            <summary>
            Adds an interpolableModel to the available interpolables list. This interpolable can then be instantiated by the user by adding a keyframe.
            User can create a single instance of this interpolable for each studio object (or single instance globally if <paramref name="useOciInHash"/> is <c>false</c>). If you want to have multiple instances of this interpolable for a single studio object use AddInterpolableModelDynamic instead.
            Try to keep the callbacks as light and self-contained as possible since they can be called on every frame during playback or UI usage (except the xml callbacks).
            </summary>
            <param name="parameter">Optional parameter for this interpolable. Mostly useful for global interpolables where required objects might be expensive to get.</param>
            <inheritdoc cref="M:KKAPI.Utilities.TimelineCompatibility.AddInterpolableModelDynamic``2(System.String,System.String,System.String,KKAPI.Utilities.TimelineCompatibility.InterpolableDelegate{``0,``1},KKAPI.Utilities.TimelineCompatibility.InterpolableDelegate{``0,``1},System.Func{Studio.ObjectCtrlInfo,System.Boolean},System.Func{Studio.ObjectCtrlInfo,``1,``0},System.Func{``1,System.Xml.XmlNode,``0},System.Action{``1,System.Xml.XmlTextWriter,``0},System.Func{Studio.ObjectCtrlInfo,``1},System.Func{Studio.ObjectCtrlInfo,System.Xml.XmlNode,``1},System.Action{Studio.ObjectCtrlInfo,System.Xml.XmlTextWriter,``1},System.Func{Studio.ObjectCtrlInfo,``1,``0,``0,System.Boolean},System.Boolean,System.Func{System.String,Studio.ObjectCtrlInfo,``1,System.String},System.Func{Studio.ObjectCtrlInfo,``1,System.Boolean})"/>
        </member>
        <member name="M:KKAPI.Utilities.TimelineCompatibility.AddInterpolableModelStatic(System.String,System.String,System.Object,System.String,KKAPI.Utilities.TimelineCompatibility.InterpolableDelegate,KKAPI.Utilities.TimelineCompatibility.InterpolableDelegate,System.Func{Studio.ObjectCtrlInfo,System.Boolean},System.Func{Studio.ObjectCtrlInfo,System.Object,System.Object},System.Func{System.Object,System.Xml.XmlNode,System.Object},System.Action{System.Object,System.Xml.XmlTextWriter,System.Object},System.Func{Studio.ObjectCtrlInfo,System.Xml.XmlNode,System.Object},System.Action{Studio.ObjectCtrlInfo,System.Xml.XmlTextWriter,System.Object},System.Func{Studio.ObjectCtrlInfo,System.Object,System.Object,System.Object,System.Boolean},System.Boolean,System.Func{System.String,Studio.ObjectCtrlInfo,System.Object,System.String},System.Func{Studio.ObjectCtrlInfo,System.Object,System.Boolean})">
            <inheritdoc cref="M:KKAPI.Utilities.TimelineCompatibility.AddInterpolableModelStatic``2(System.String,System.String,``1,System.String,KKAPI.Utilities.TimelineCompatibility.InterpolableDelegate{``0,``1},KKAPI.Utilities.TimelineCompatibility.InterpolableDelegate{``0,``1},System.Func{Studio.ObjectCtrlInfo,System.Boolean},System.Func{Studio.ObjectCtrlInfo,``1,``0},System.Func{``1,System.Xml.XmlNode,``0},System.Action{``1,System.Xml.XmlTextWriter,``0},System.Func{Studio.ObjectCtrlInfo,System.Xml.XmlNode,``1},System.Action{Studio.ObjectCtrlInfo,System.Xml.XmlTextWriter,``1},System.Func{Studio.ObjectCtrlInfo,``1,``0,``0,System.Boolean},System.Boolean,System.Func{System.String,Studio.ObjectCtrlInfo,``1,System.String},System.Func{Studio.ObjectCtrlInfo,``1,System.Boolean})"/>
        </member>
        <member name="M:KKAPI.Utilities.TimelineCompatibility.AddCharaFunctionInterpolable``2(System.String,System.String,System.String,KKAPI.Utilities.TimelineCompatibility.InterpolableCharaDelegate{``0,``1},KKAPI.Utilities.TimelineCompatibility.InterpolableCharaDelegate{``0,``1},System.Func{Studio.OCIChar,``1,``0},System.Func{``1,System.Xml.XmlNode,``0},System.Action{``1,System.Xml.XmlTextWriter,``0},System.Func{Studio.OCIChar,``1,``0,``0,System.Boolean},System.Boolean,System.Func{System.String,Studio.OCIChar,``1,System.String},System.Func{Studio.OCIChar,``1,System.Boolean})">
            <summary>
            Adds an interpolableModel that targets CharaCustomFunctionControllers on characters to the available interpolables list. This interpolable can then be instantiated by the user by adding a keyframe.
            </summary>
            <typeparam name="TValue">The type of the value.</typeparam>
            <typeparam name="TController">Type of a plugin's <see cref="T:KKAPI.Chara.CharaCustomFunctionController"/>.</typeparam>
            <inheritdoc cref="M:KKAPI.Utilities.TimelineCompatibility.AddInterpolableModelDynamic``2(System.String,System.String,System.String,KKAPI.Utilities.TimelineCompatibility.InterpolableDelegate{``0,``1},KKAPI.Utilities.TimelineCompatibility.InterpolableDelegate{``0,``1},System.Func{Studio.ObjectCtrlInfo,System.Boolean},System.Func{Studio.ObjectCtrlInfo,``1,``0},System.Func{``1,System.Xml.XmlNode,``0},System.Action{``1,System.Xml.XmlTextWriter,``0},System.Func{Studio.ObjectCtrlInfo,``1},System.Func{Studio.ObjectCtrlInfo,System.Xml.XmlNode,``1},System.Action{Studio.ObjectCtrlInfo,System.Xml.XmlTextWriter,``1},System.Func{Studio.ObjectCtrlInfo,``1,``0,``0,System.Boolean},System.Boolean,System.Func{System.String,Studio.ObjectCtrlInfo,``1,System.String},System.Func{Studio.ObjectCtrlInfo,``1,System.Boolean})"/>
        </member>
        <member name="M:KKAPI.Utilities.TimelineCompatibility.RefreshInterpolablesList">
            <summary>
            Refreshes the list of displayed interpolables. This function is quite heavy as it must go through each InterpolableModel and check if it's compatible with the current target.
            It is called automatically by Timeline when selecting another Workspace object or GuideObject.
            This triggers visibility checks of all interpolables and can be used to force update all instances of your interpolables if something important changes and Timeline doesn't notice it.
            </summary>
        </member>
        <member name="T:KKAPI.Utilities.ConfigurationManagerAttributes">
            <summary>
            Class that specifies how a setting should be displayed inside the ConfigurationManager settings window.
            
            Usage:
            You can use this copy of the class instead of including it in your own plugin.
            Make a new instance, assign any fields that you want to override, and pass it as a tag for your setting.
            
            If a field is null (default), it will be ignored and won't change how the setting is displayed.
            If a field is non-null (you assigned a value to it), it will override default behavior.
            </summary>
            
            <example> 
            Here's an example of overriding order of settings and marking one of the settings as advanced:
            <code>
            // Override IsAdvanced and Order
            Config.AddSetting("X", "1", 1, new ConfigDescription("", null, new ConfigurationManagerAttributes { IsAdvanced = true, Order = 3 }));
            // Override only Order, IsAdvanced stays as the default value assigned by ConfigManager
            Config.AddSetting("X", "2", 2, new ConfigDescription("", null, new ConfigurationManagerAttributes { Order = 1 }));
            Config.AddSetting("X", "3", 3, new ConfigDescription("", null, new ConfigurationManagerAttributes { Order = 2 }));
            </code>
            </example>
            
            <remarks> 
            You can read more and see examples in the readme at https://github.com/BepInEx/BepInEx.ConfigurationManager
            You can optionally remove fields that you won't use from this class, it's the same as leaving them null.
            </remarks>
        </member>
        <member name="F:KKAPI.Utilities.ConfigurationManagerAttributes.ShowRangeAsPercent">
            <summary>
            Should the setting be shown as a percentage (only use with value range settings).
            </summary>
        </member>
        <member name="F:KKAPI.Utilities.ConfigurationManagerAttributes.CustomDrawer">
            <summary>
            Custom setting editor (OnGUI code that replaces the default editor provided by ConfigurationManager).
            See below for a deeper explanation. Using a custom drawer will cause many of the other fields to do nothing.
            </summary>
        </member>
        <member name="F:KKAPI.Utilities.ConfigurationManagerAttributes.Browsable">
            <summary>
            Show this setting in the settings screen at all? If false, don't show.
            </summary>
        </member>
        <member name="F:KKAPI.Utilities.ConfigurationManagerAttributes.Category">
            <summary>
            Category the setting is under. Null to be directly under the plugin.
            </summary>
        </member>
        <member name="F:KKAPI.Utilities.ConfigurationManagerAttributes.DefaultValue">
            <summary>
            If set, a "Default" button will be shown next to the setting to allow resetting to default.
            </summary>
        </member>
        <member name="F:KKAPI.Utilities.ConfigurationManagerAttributes.HideDefaultButton">
            <summary>
            Force the "Reset" button to not be displayed, even if a valid DefaultValue is available. 
            </summary>
        </member>
        <member name="F:KKAPI.Utilities.ConfigurationManagerAttributes.HideSettingName">
            <summary>
            Force the setting name to not be displayed. Should only be used with a <see cref="F:KKAPI.Utilities.ConfigurationManagerAttributes.CustomDrawer"/> to get more space.
            Can be used together with <see cref="F:KKAPI.Utilities.ConfigurationManagerAttributes.HideDefaultButton"/> to gain even more space.
            </summary>
        </member>
        <member name="F:KKAPI.Utilities.ConfigurationManagerAttributes.Description">
            <summary>
            Optional description shown when hovering over the setting.
            Not recommended, provide the description when creating the setting instead.
            </summary>
        </member>
        <member name="F:KKAPI.Utilities.ConfigurationManagerAttributes.DispName">
            <summary>
            Name of the setting.
            </summary>
        </member>
        <member name="F:KKAPI.Utilities.ConfigurationManagerAttributes.Order">
            <summary>
            Order of the setting on the settings list relative to other settings in a category.
            0 by default, higher number is higher on the list.
            </summary>
        </member>
        <member name="F:KKAPI.Utilities.ConfigurationManagerAttributes.ReadOnly">
            <summary>
            Only show the value, don't allow editing it.
            </summary>
        </member>
        <member name="F:KKAPI.Utilities.ConfigurationManagerAttributes.IsAdvanced">
            <summary>
            If true, don't show the setting by default. User has to turn on showing advanced settings or search for it.
            </summary>
        </member>
        <member name="F:KKAPI.Utilities.ConfigurationManagerAttributes.ObjToStr">
            <summary>
            Custom converter from setting type to string for the built-in editor textboxes.
            </summary>
        </member>
        <member name="F:KKAPI.Utilities.ConfigurationManagerAttributes.StrToObj">
            <summary>
            Custom converter from string to setting type for the built-in editor textboxes.
            </summary>
        </member>
        <member name="T:KKAPI.Utilities.CoroutineUtils">
            <summary>
            Utility methods for working with coroutines.
            </summary>
        </member>
        <member name="M:KKAPI.Utilities.CoroutineUtils.AppendCo(System.Collections.IEnumerator,System.Collections.IEnumerator)">
            <summary>
            Create a coroutine that calls the appendCoroutine after baseCoroutine finishes
            </summary>
        </member>
        <member name="M:KKAPI.Utilities.CoroutineUtils.AppendCo(System.Collections.IEnumerator,UnityEngine.YieldInstruction)">
            <summary>
            Create a coroutine that calls the yieldInstruction after baseCoroutine finishes.
            Useless on its own, append further coroutines to run after this.
            </summary>
        </member>
        <member name="M:KKAPI.Utilities.CoroutineUtils.AppendCo(System.Collections.IEnumerator,System.Action[])">
            <summary>
            Create a coroutine that calls each of the actions in order after base coroutine finishes.
            One action is called per frame. First action is called right after the coroutine finishes.
            </summary>
        </member>
        <member name="M:KKAPI.Utilities.CoroutineUtils.CreateCoroutine(System.Action[])">
            <summary>
            Create a coroutine that calls each of the action delegates on consecutive frames.
            One action is called per frame. First action is called right away. There is no frame skip after the last action.
            </summary>
        </member>
        <member name="M:KKAPI.Utilities.CoroutineUtils.CreateCoroutine(UnityEngine.YieldInstruction,System.Action[])">
            <summary>
            Create a coroutine that calls each of the action delegates on consecutive frames.
            One action is called per frame. First action is called right after the yieldInstruction. There is no frame skip after the last action.
            </summary>
        </member>
        <member name="M:KKAPI.Utilities.CoroutineUtils.ComposeCoroutine(System.Collections.IEnumerator[])">
            <summary>
            Create a coroutine that calls each of the supplied coroutines in order.
            </summary>
        </member>
        <member name="M:KKAPI.Utilities.CoroutineUtils.AttachToYield(System.Collections.IEnumerator,System.Action)">
            <summary>
            Create a coroutine that is the same as the supplied coroutine, except every time it yields the onYieldAction is invoked.
            (i.e. onYieldAction is invoked after every yield return in the original coroutine)
            If the coroutine returns another coroutine, the action is not called for yields performed by the returned coroutine, only the topmost one. Use FlattenCo if that's an issue.
            </summary>
        </member>
        <member name="M:KKAPI.Utilities.CoroutineUtils.FlattenCo(System.Collections.IEnumerator)">
            <summary>
            Flatten the coroutine to yield all values directly. Any coroutines yield returned by this coroutine will have their values directly returned by this new coroutine (this is recursive).
            For example if another coroutine is yielded by this coroutine, the yielded coroutine will not be returned and instead the values that it yields will be returned.
            If a yielded coroutine yields yet another coroutine, that second coroutine's values will be returned directly from the flattened coroutine.
            </summary>
        </member>
        <member name="M:KKAPI.Utilities.CoroutineUtils.StripYields(System.Collections.IEnumerator,System.Boolean,System.Boolean)">
            <summary>
            Remove yields from the coroutine, making its code run immediately.
            </summary>
            <param name="coroutine">Coroutine to strip</param>
            <param name="onlyStripNulls">Should only yield return null be stripped? If false, all yields are stripped</param>
            <param name="flatten">
            Should the coroutine be flattened before stripping it? 
            If this is false then yields from coroutines returned by this coroutine will not be stripped. 
            If this and onlyStripNulls are both false, coroutines returned by this coroutine will not be executed.
            </param>
        </member>
        <member name="M:KKAPI.Utilities.CoroutineUtils.RunImmediately(System.Collections.IEnumerator)">
            <summary>
            Fully executes the coroutine synchronously (immediately run all of its code till completion).
            </summary>
        </member>
        <member name="M:KKAPI.Utilities.CoroutineUtils.PreventFromCrashing(System.Collections.IEnumerator)">
            <summary>
            Prevent a coroutine from getting stopped by exceptions. Exceptions are caught and logged.
            Code after the exception is thrown doesn't run up until the next yield. The coroutine continues after the yield then.
            </summary>
        </member>
        <member name="M:KKAPI.Utilities.CoroutineUtils.GetMoveNext(System.Reflection.MethodBase)">
            <summary>
            Find the compiler-generated MoveNext method that contains the Coroutine/UniTask code. It can be used to apply transpliers to Coroutines and UniTasks.
            Note: When writing transpliers for coroutines you might want to turn off the "Decompiler\Decompile enumerators" setting in DnSpy so that you can see the real code.
            UniTasks are considered "async/await" so you need to turn off the "Decompile async methods" setting instead.
            </summary>
        </member>
        <member name="M:KKAPI.Utilities.CoroutineUtils.PatchMoveNext(HarmonyLib.Harmony,System.Reflection.MethodBase,HarmonyLib.HarmonyMethod,HarmonyLib.HarmonyMethod,HarmonyLib.HarmonyMethod,HarmonyLib.HarmonyMethod,HarmonyLib.HarmonyMethod)">
            <summary>
            Used to patch coroutines/IEnumerator methods and async UniTask methods.
            This will method automatically find the compiler-generated MoveNext method that contains the coroutine code and apply patches on that. The method you patch must return an IEnumerator or an UniTask.
            Warning: Postfix patches will not work as expected, they might be fired after every iteration. Prefix is practically the same as prefixing the entry method. It's best to only use transpliers with this method.
            Note: When writing transpliers you might want to turn off the "Decompiler\Decompile enumerators/async" settings in DnSpy so that you can see the real code.
            </summary>
            <inheritdoc cref="M:HarmonyLib.Harmony.Patch(System.Reflection.MethodBase,HarmonyLib.HarmonyMethod,HarmonyLib.HarmonyMethod,HarmonyLib.HarmonyMethod,HarmonyLib.HarmonyMethod,HarmonyLib.HarmonyMethod)"/>
        </member>
        <member name="F:KKAPI.Utilities.CoroutineUtils.WaitForEndOfFrame">
            <summary>
            Cached WaitForEndOfFrame. Use instead of creating a new instance every time to reduce garbage production.
            </summary>
        </member>
        <member name="M:KKAPI.Utilities.CoroutineUtils.StopCoOnQuit(System.Collections.IEnumerator)">
            <summary>
            Create a coroutine that is the same as the supplied coroutine, but will stop early if <see cref="P:KKAPI.KoikatuAPI.IsQuitting"/> is <c>true</c>.
            If the coroutine returns another coroutine, the <see cref="P:KKAPI.KoikatuAPI.IsQuitting"/> check only runs on the topmost one. Use <see cref="M:KKAPI.Utilities.CoroutineUtils.FlattenCo(System.Collections.IEnumerator)" /> if that's an issue.
            </summary>
        </member>
        <member name="T:KKAPI.Utilities.HSceneUtils">
            <summary>
            Utility methods for working with H Scenes / main game.
            </summary>
        </member>
        <member name="T:KKAPI.Utilities.IMGUIUtils">
            <summary>
            Utility methods for working with IMGUI / OnGui.
            </summary>
        </member>
        <member name="P:KKAPI.Utilities.IMGUIUtils.SolidBackgroundGuiSkin">
            <summary>
            A custom GUISkin with a solid background, sharper edges and less padding.
            The skin background color is adjusted to the game (if its color filter affects imgui layer).
            Warning: Only use inside OnGUI or things might break.
            </summary>
        </member>
        <member name="M:KKAPI.Utilities.IMGUIUtils.DrawSolidBox(UnityEngine.Rect)">
            <summary>
            Draw a gray non-transparent GUI.Box at the specified rect. Use before a GUI.Window or other controls to get rid of 
            the default transparency and make the GUI easier to read.
            <example>
            IMGUIUtils.DrawSolidBox(screenRect);
            GUILayout.Window(362, screenRect, TreeWindow, "Select character folder");
            </example>
            </summary>
        </member>
        <member name="M:KKAPI.Utilities.IMGUIUtils.EatInputInRect(UnityEngine.Rect)">
            <summary>
            Block input from going through to the game/canvases if the mouse cursor is within the specified Rect.
            Use after a GUI.Window call or the window will not be able to get the inputs either.
            <example>
            GUILayout.Window(362, screenRect, TreeWindow, "Select character folder");
            Utils.EatInputInRect(screenRect);
            </example>
            </summary>
            <param name="eatRect"></param>
        </member>
        <member name="M:KKAPI.Utilities.IMGUIUtils.DrawLabelWithOutline(UnityEngine.Rect,System.String,UnityEngine.GUIStyle,UnityEngine.Color,UnityEngine.Color,System.Int32)">
            <summary>
            Draw a label with an outline
            </summary>
            <param name="rect">Size of the control</param>
            <param name="text">Text of the label</param>
            <param name="style">Style to be applied to the label</param>
            <param name="txtColor">Color of the text</param>
            <param name="outlineColor">Color of the outline</param>
            <param name="outlineThickness">Thickness of the outline in pixels</param>
        </member>
        <member name="M:KKAPI.Utilities.IMGUIUtils.DrawLabelWithShadow(UnityEngine.Rect,UnityEngine.GUIContent,UnityEngine.GUIStyle,UnityEngine.Color,UnityEngine.Color,UnityEngine.Vector2)">
            <summary>
            Draw a label with a shadow
            </summary>        
            <param name="rect">Size of the control</param>
            <param name="content">Contents of the label</param>
            <param name="style">Style to be applied to the label</param>
            <param name="txtColor">Color of the outline</param>
            <param name="shadowColor">Color of the text</param>
            <param name="shadowOffset">Offset of the shadow in pixels</param>
        </member>
        <member name="M:KKAPI.Utilities.IMGUIUtils.DrawLayoutLabelWithShadow(UnityEngine.GUIContent,UnityEngine.GUIStyle,UnityEngine.Color,UnityEngine.Color,UnityEngine.Vector2,UnityEngine.GUILayoutOption[])">
            <inheritdoc cref="M:KKAPI.Utilities.IMGUIUtils.DrawLabelWithShadow(UnityEngine.Rect,UnityEngine.GUIContent,UnityEngine.GUIStyle,UnityEngine.Color,UnityEngine.Color,UnityEngine.Vector2)"/>
        </member>
        <member name="M:KKAPI.Utilities.IMGUIUtils.DrawButtonWithShadow(UnityEngine.Rect,UnityEngine.GUIContent,UnityEngine.GUIStyle,System.Single,UnityEngine.Vector2)">
            <inheritdoc cref="M:KKAPI.Utilities.IMGUIUtils.DrawLabelWithShadow(UnityEngine.Rect,UnityEngine.GUIContent,UnityEngine.GUIStyle,UnityEngine.Color,UnityEngine.Color,UnityEngine.Vector2)"/>
        </member>
        <member name="M:KKAPI.Utilities.IMGUIUtils.DrawLayoutButtonWithShadow(UnityEngine.GUIContent,UnityEngine.GUIStyle,System.Single,UnityEngine.Vector2,UnityEngine.GUILayoutOption[])">
            <inheritdoc cref="M:KKAPI.Utilities.IMGUIUtils.DrawLabelWithShadow(UnityEngine.Rect,UnityEngine.GUIContent,UnityEngine.GUIStyle,UnityEngine.Color,UnityEngine.Color,UnityEngine.Vector2)"/>
        </member>
        <member name="M:KKAPI.Utilities.IMGUIUtils.DragResizeWindow(System.Int32,UnityEngine.Rect)">
            <summary>
            Handle both dragging and resizing of OnGUI windows.
            Use this instead of GUI.DragWindow(), don't use both at the same time.
            To use, place this at the end of your Window method: _windowRect = IMGUIUtils.DragResizeWindow(windowId, _windowRect);
            </summary>
            <param name="windowId">The ID passed to your window method</param>
            <param name="windowRect">The rect of your window. Make sure to set it to the result of this method</param>
        </member>
        <member name="M:KKAPI.Utilities.IMGUIUtils.DragResizeEatWindow(System.Int32,UnityEngine.Rect)">
            <summary>
            Handle both dragging and resizing of OnGUI windows, as well as eat mouse inputs when cursor is over the window.
            Use this instead of <see cref="M:UnityEngine.GUI.DragWindow(UnityEngine.Rect)"/> and <see cref="M:KKAPI.Utilities.IMGUIUtils.EatInputInRect(UnityEngine.Rect)"/>. Don't use these methods at the same time as DragResizeEatWindow.
            To use, place this at the end of your Window method: _windowRect = IMGUIUtils.DragResizeEatWindow(windowId, _windowRect);
            </summary>
            <param name="windowId">The ID passed to your window method</param>
            <param name="windowRect">The rect of your window. Make sure to set it to the result of this method</param>
        </member>
        <member name="M:KKAPI.Utilities.IMGUIUtils.DrawTooltip(UnityEngine.Rect,System.Int32)">
            <summary>
            Display a tooltip for any GUIContent with the tootlip property set in a given window.
            To use, place this at the end of your Window method: IMGUIUtils.DrawTooltip(_windowRect);
            </summary>
            <param name="area">Area where the tooltip can appear</param>
            <param name="tooltipWidth">Minimum width of the tooltip, can't be larger than area's width</param>
        </member>
        <member name="T:KKAPI.Utilities.MemoryInfo">
            <summary>
            Provides information about system memory status
            </summary>
        </member>
        <member name="M:KKAPI.Utilities.MemoryInfo.GetCurrentStatus">
            <summary>
            Can return null if the call fails for whatever reason
            </summary>
        </member>
        <member name="T:KKAPI.Utilities.MemoryInfo.MEMORYSTATUSEX">
            <summary>
            contains information about the current state of both physical and virtual memory, including extended memory
            </summary>
        </member>
        <member name="F:KKAPI.Utilities.MemoryInfo.MEMORYSTATUSEX.dwLength">
            <summary>
            Size of the structure, in bytes. You must set this member before calling GlobalMemoryStatusEx.
            </summary>
        </member>
        <member name="F:KKAPI.Utilities.MemoryInfo.MEMORYSTATUSEX.dwMemoryLoad">
            <summary>
            Number between 0 and 100 that specifies the approximate percentage of physical memory that is in use (0 indicates no memory use and 100 indicates full memory use).
            </summary>
        </member>
        <member name="F:KKAPI.Utilities.MemoryInfo.MEMORYSTATUSEX.ullTotalPhys">
            <summary>
            Total size of physical memory, in bytes.
            </summary>
        </member>
        <member name="F:KKAPI.Utilities.MemoryInfo.MEMORYSTATUSEX.ullAvailPhys">
            <summary>
            Size of physical memory available, in bytes.
            </summary>
        </member>
        <member name="F:KKAPI.Utilities.MemoryInfo.MEMORYSTATUSEX.ullTotalPageFile">
            <summary>
            Size of the committed memory limit, in bytes. This is physical memory plus the size of the page file, minus a small overhead.
            </summary>
        </member>
        <member name="F:KKAPI.Utilities.MemoryInfo.MEMORYSTATUSEX.ullAvailPageFile">
            <summary>
            Size of available memory to commit, in bytes. The limit is ullTotalPageFile.
            </summary>
        </member>
        <member name="F:KKAPI.Utilities.MemoryInfo.MEMORYSTATUSEX.ullTotalVirtual">
            <summary>
            Total size of the user mode portion of the virtual address space of the calling process, in bytes.
            </summary>
        </member>
        <member name="F:KKAPI.Utilities.MemoryInfo.MEMORYSTATUSEX.ullAvailVirtual">
            <summary>
            Size of unreserved and uncommitted memory in the user mode portion of the virtual address space of the calling process, in bytes.
            </summary>
        </member>
        <member name="F:KKAPI.Utilities.MemoryInfo.MEMORYSTATUSEX.ullAvailExtendedVirtual">
            <summary>
            Size of unreserved and uncommitted memory in the extended portion of the virtual address space of the calling process, in bytes.
            </summary>
        </member>
        <member name="M:KKAPI.Utilities.MemoryInfo.MEMORYSTATUSEX.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:MEMORYSTATUSEX"/> class.
            </summary>
        </member>
        <member name="T:KKAPI.Utilities.ObservableExtensions">
            <summary>
            Additions to the UniRx IObservable extension methods
            </summary>
        </member>
        <member name="M:KKAPI.Utilities.ObservableExtensions.OnGUIAsObservable(UnityEngine.Component)">
            <summary>
            Get an observable that triggers on every OnGUI call on this gameObject
            </summary>
        </member>
        <member name="M:KKAPI.Utilities.ObservableExtensions.OnGUIAsObservable(UnityEngine.Transform)">
            <inheritdoc cref="M:KKAPI.Utilities.ObservableExtensions.OnGUIAsObservable(UnityEngine.Component)"/>
        </member>
        <member name="M:KKAPI.Utilities.ObservableExtensions.OnGUIAsObservable(UnityEngine.GameObject)">
            <inheritdoc cref="M:KKAPI.Utilities.ObservableExtensions.OnGUIAsObservable(UnityEngine.Component)"/>
        </member>
        <member name="T:KKAPI.Utilities.ObservableOnGUITrigger">
            <summary>
            Trigger component that implements <see cref="M:KKAPI.Utilities.ObservableExtensions.OnGUIAsObservable(UnityEngine.Component)"/>
            </summary>
        </member>
        <member name="M:KKAPI.Utilities.ObservableOnGUITrigger.OnGUIAsObservable">
            <summary>
            Get observable that triggers every time this component's OnGUI is called
            </summary>
        </member>
        <member name="M:KKAPI.Utilities.ObservableOnGUITrigger.RaiseOnCompletedOnDestroy">
            <inheritdoc />
        </member>
        <member name="T:KKAPI.Utilities.ReadOnlyDictionary`2">
            <summary>
            Read-only dictionary wrapper. Will protect the base dictionary from being changed.
            Warning: Any reference types inside the dictionary can still be modified.
            </summary>
            <inheritdoc />
        </member>
        <member name="M:KKAPI.Utilities.ReadOnlyDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
            <summary>
            Create a new wrapper around the specified dictionary
            </summary>
        </member>
        <member name="T:KKAPI.Utilities.ResourceUtils">
            <summary>
            Utility methods for working with embedded resources.
            </summary>
        </member>
        <member name="M:KKAPI.Utilities.ResourceUtils.ReadAllBytes(System.IO.Stream)">
            <summary>
            Read all bytes starting at current position and ending at the end of the stream.
            </summary>
        </member>
        <member name="M:KKAPI.Utilities.ResourceUtils.GetEmbeddedResource(System.String,System.Reflection.Assembly)">
            <summary>
            Get a file set as "Embedded Resource" from the assembly that is calling this code, or optionally from a specified assembly.
            The filename is matched to the end of the resource path, no need to give the full path.
            If 0 or more than 1 resources match the provided filename, an exception is thrown.
            For example if you have a file "ProjectRoot\Resources\icon.png" set as "Embedded Resource", you can use this to load it by
            doing <code>GetEmbeddedResource("icon.png"), assuming that no other embedded files have the same name.</code>
            </summary>
            <exception cref="T:System.IO.IOException">Thrown if none or more than one resources were found matching the given resourceFileName</exception>
        </member>
        <member name="T:KKAPI.Utilities.TextureUtils">
            <summary>
            Utility methods for working with texture objects.
            </summary>
        </member>
        <member name="M:KKAPI.Utilities.TextureUtils.ToTexture2D(UnityEngine.Texture,UnityEngine.TextureFormat,System.Boolean)">
            <summary>
            Copy this texture inside a new editable Texture2D.
            </summary>
            <param name="tex">Texture to copy</param>
            <param name="format">Format of the copy</param>
            <param name="mipMaps">Copy has mipmaps</param>
        </member>
        <member name="M:KKAPI.Utilities.TextureUtils.LoadTexture(System.Byte[],UnityEngine.TextureFormat,System.Boolean)">
            <summary>
            Create texture from an image stored in a byte array, for example a png file read from disk.
            </summary>
        </member>
        <member name="M:KKAPI.Utilities.TextureUtils.ToSprite(UnityEngine.Texture2D)">
            <summary>
            Create a sprite based on this texture.
            </summary>
        </member>
        <member name="T:KKAPI.Utilities.TextureUtils.ImageFilterMode">
            <summary>
            Filtering to use when resizing a texture
            </summary>
        </member>
        <member name="F:KKAPI.Utilities.TextureUtils.ImageFilterMode.Nearest">
            <summary>
            Nearest pixel, fastest but gets aliased
            </summary>
        </member>
        <member name="F:KKAPI.Utilities.TextureUtils.ImageFilterMode.Biliner">
            <summary>
            Use bilinear scaling
            </summary>
        </member>
        <member name="F:KKAPI.Utilities.TextureUtils.ImageFilterMode.Average">
            <summary>
            Average of all nearby pixels
            </summary>
        </member>
        <member name="M:KKAPI.Utilities.TextureUtils.ResizeTexture(UnityEngine.Texture2D,KKAPI.Utilities.TextureUtils.ImageFilterMode,System.Single)">
            <summary>
            Create a resized copy of this texture.
            http://blog.collectivemass.com/2014/03/resizing-textures-in-unity/
            </summary>
            <param name="pSource">Texture to resize</param>
            <param name="pFilterMode">How to resize</param>
            <param name="pScale">New scale</param>
        </member>
        <member name="T:KKAPI.Utilities.TextUtils">
            <summary>
            Utility methods for working with text.
            </summary>
        </member>
        <member name="M:KKAPI.Utilities.TextUtils.PascalCaseToSentenceCase(System.String)">
            <summary>
            Convert PascalCase to Sentence case.
            </summary>
        </member>
        <member name="T:KKAPI.Utilities.OpenFileDialog">
            <summary>
            Gives access to the Windows open file dialog.
            http://www.pinvoke.net/default.aspx/comdlg32/GetOpenFileName.html
            http://www.pinvoke.net/default.aspx/Structures/OpenFileName.html
            http://www.pinvoke.net/default.aspx/Enums/OpenSaveFileDialgueFlags.html
            https://social.msdn.microsoft.com/Forums/en-US/2f4dd95e-5c7b-4f48-adfc-44956b350f38/getopenfilename-for-multiple-files?forum=csharpgeneral
            </summary>
        </member>
        <member name="F:KKAPI.Utilities.OpenFileDialog.SingleFileFlags">
            <summary>
            Arguments used for opening a single file
            </summary>
        </member>
        <member name="F:KKAPI.Utilities.OpenFileDialog.MultiFileFlags">
            <summary>
            Arguments used for opening multiple files
            </summary>
        </member>
        <member name="M:KKAPI.Utilities.OpenFileDialog.ShowDialog(System.String,System.String,System.String,System.String,KKAPI.Utilities.OpenFileDialog.OpenSaveFileDialgueFlags,System.IntPtr)">
            <inheritdoc cref="M:KKAPI.Utilities.OpenFileDialog.ShowDialog(System.String,System.String,System.String,System.String,KKAPI.Utilities.OpenFileDialog.OpenSaveFileDialgueFlags,System.String,System.IntPtr)"/>
        </member>
        <member name="M:KKAPI.Utilities.OpenFileDialog.ShowDialog(System.String,System.String,System.String,System.String,KKAPI.Utilities.OpenFileDialog.OpenSaveFileDialgueFlags,System.String,System.IntPtr)">
            <summary>
            Show windows file open dialog. Blocks the thread until user closes the dialog. Returns list of selected files, or null if user cancelled the action.
            </summary>
            <param name="title">
            A string to be placed in the title bar of the dialog box. If this member is NULL, the system uses
            the default title (that is, Save As or Open)
            </param>
            <param name="initialDir">
            The initial directory. The algorithm for selecting the initial directory varies on different
            platforms.
            </param>
            <param name="filter">
            A list of filter pairs separated by |. First item is the display name, while the second is
            the actual filter (e.g. *.txt) Example: <code>"Log files (.log)|*.log|All files|*.*"</code>
            </param>
            <param name="defaultExt">
            The default extension. This extension is appended to the file name if the user fails to type
            an extension.
            </param>
            <param name="flags">
            A set of bit flags you can use to initialize the dialog box. When the dialog box returns, it sets these flags to
            indicate the user's input.
            This member can be a combination of the CommomDialgueFlags.
            </param>
            <param name="owner">Hwnd pointer of the owner window. IntPtr.Zero to use default parent</param>
            <param name="defaultFilename"> Filename that is initially entered in the filename box. </param>
        </member>
        <member name="M:KKAPI.Utilities.OpenFileDialog.Show(System.Action{System.String[]},System.String,System.String,System.String,System.String,KKAPI.Utilities.OpenFileDialog.OpenSaveFileDialgueFlags)">
            <summary>
            Show windows file open dialog. Doesn't pause the game.
            </summary>
            <param name="onAccept">Action that gets called with results of user's selection. Returns list of selected files, or null if user cancelled the action.
            WARNING: This runs on another thread! Game will crash if you attempt to access unity methods.
            You can use <code>KoikatuAPI.SynchronizedInvoke</code> to go back to the main thread.</param>
            <param name="title">
            A string to be placed in the title bar of the dialog box. If this member is NULL, the system uses
            the default title (that is, Save As or Open)
            </param>
            <param name="initialDir">
            The initial directory. The algorithm for selecting the initial directory varies on different
            platforms.
            </param>
            <param name="filter">
            A list of filter pairs separated by |. First item is the display name, while the second is
            the actual filter (e.g. *.txt) Example: <code>"Log files (.log)|*.log|All files|*.*"</code>
            </param>
            <param name="defaultExt">
            The default extension. This extension is appended to the file name if the user fails to type
            an extension.
            </param>
            <param name="flags">
            A set of bit flags you can use to initialize the dialog box. When the dialog box returns, it sets these flags to
            indicate the user's input.
            This member can be a combination of the CommomDialgueFlags.
            </param>
        </member>
        <member name="F:KKAPI.Utilities.OpenFileDialog.OpenSaveFileDialgueFlags.OFN_NOLONGNAMES">
            <summary>
            Force no long names for 4.x modules
            </summary>
        </member>
        <member name="F:KKAPI.Utilities.OpenFileDialog.OpenSaveFileDialgueFlags.OFN_EXPLORER">
            <summary>
            New look commdlg
            </summary>
        </member>
        <member name="F:KKAPI.Utilities.OpenFileDialog.OpenSaveFileDialgueFlags.OFN_LONGNAMES">
            <summary>
            Force long names for 3.x modules
            </summary>
        </member>
        <member name="T:KKAPI.Utilities.RecycleBinUtil">
            <summary>
            Allows to move files to recycle bin instead of completely removing them.
            https://stackoverflow.com/questions/3282418/send-a-file-to-the-recycle-bin?answertab=votes#tab-top
            </summary>
        </member>
        <member name="M:KKAPI.Utilities.RecycleBinUtil.MoveToRecycleBin(System.String,KKAPI.Utilities.RecycleBinUtil.FileOperationFlags)">
            <summary>
            Send file to recycle bin
            </summary>
            <param name="path">Location of directory or file to recycle</param>
            <param name="flags">FileOperationFlags to add in addition to FOF_ALLOWUNDO</param>
        </member>
        <member name="M:KKAPI.Utilities.RecycleBinUtil.MoveToRecycleBin(System.String)">
            <summary>
            Send file silently to recycle bin.  Surpress dialog, surpress errors, delete if too large.
            </summary>
            <param name="path">Location of directory or file to recycle</param>
        </member>
        <member name="T:KKAPI.Utilities.RecycleBinUtil.FileOperationFlags">
            <summary>
            Possible flags for the SHFileOperation method.
            </summary>
        </member>
        <member name="F:KKAPI.Utilities.RecycleBinUtil.FileOperationFlags.FOF_SILENT">
            <summary>
            Do not show a dialog during the process
            </summary>
        </member>
        <member name="F:KKAPI.Utilities.RecycleBinUtil.FileOperationFlags.FOF_NOCONFIRMATION">
            <summary>
            Do not ask the user to confirm selection
            </summary>
        </member>
        <member name="F:KKAPI.Utilities.RecycleBinUtil.FileOperationFlags.FOF_ALLOWUNDO">
            <summary>
            Delete the file to the recycle bin.  (Required flag to send a file to the bin
            </summary>
        </member>
        <member name="F:KKAPI.Utilities.RecycleBinUtil.FileOperationFlags.FOF_SIMPLEPROGRESS">
            <summary>
            Do not show the names of the files or folders that are being recycled.
            </summary>
        </member>
        <member name="F:KKAPI.Utilities.RecycleBinUtil.FileOperationFlags.FOF_NOERRORUI">
            <summary>
            Surpress errors, if any occur during the process.
            </summary>
        </member>
        <member name="F:KKAPI.Utilities.RecycleBinUtil.FileOperationFlags.FOF_WANTNUKEWARNING">
            <summary>
            Warn if files are too big to fit in the recycle bin and will need
            to be deleted completely.
            </summary>
        </member>
        <member name="T:KKAPI.Utilities.RecycleBinUtil.FileOperationType">
            <summary>
            File Operation Function Type for SHFileOperation
            </summary>
        </member>
        <member name="F:KKAPI.Utilities.RecycleBinUtil.FileOperationType.FO_MOVE">
            <summary>
            Move the objects
            </summary>
        </member>
        <member name="F:KKAPI.Utilities.RecycleBinUtil.FileOperationType.FO_COPY">
            <summary>
            Copy the objects
            </summary>
        </member>
        <member name="F:KKAPI.Utilities.RecycleBinUtil.FileOperationType.FO_DELETE">
            <summary>
            Delete (or recycle) the objects
            </summary>
        </member>
        <member name="F:KKAPI.Utilities.RecycleBinUtil.FileOperationType.FO_RENAME">
            <summary>
            Rename the object(s)
            </summary>
        </member>
        <member name="T:KKAPI.Utilities.RecycleBinUtil.SHFILEOPSTRUCT">
            <summary>
            SHFILEOPSTRUCT for SHFileOperation from COM
            </summary>
        </member>
        <member name="T:KKAPI.Utilities.Extensions">
            <summary>
            General utility extensions that don't fit in other categories.
            </summary>
        </member>
        <member name="M:KKAPI.Utilities.Extensions.ToReadOnlyDictionary``2(System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            Wrap this dictionary in a read-only wrapper that will prevent any changes to it. 
            Warning: Any reference types inside the dictionary can still be modified.
            </summary>
        </member>
        <member name="M:KKAPI.Utilities.Extensions.MarkXuaIgnored(UnityEngine.Component)">
            <summary>
            Mark GameObject of this Component as ignored by AutoTranslator. Prevents AutoTranslator from trying to translate custom UI elements.
            </summary>
        </member>
        <member name="M:KKAPI.Utilities.Extensions.ActuallyRemoveAllListeners(UnityEngine.Events.UnityEventBase)">
            <summary>
            Same as RemoveAllListeners but also disables all PersistentListeners.
            To avoid frustration always use this instead of RemoveAllListeners, unless you want to keep the PersistentListeners.
            </summary>
        </member>
        <member name="M:KKAPI.Utilities.Extensions.Attempt``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Attempt to project each element of the sequence into a new form (Select but ignore exceptions).
            Exceptions thrown while doing this are ignored and any elements that fail to be converted are silently skipped.
            </summary>
        </member>
        <member name="M:KKAPI.Utilities.Extensions.Attempt``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Action{System.Exception})">
            <inheritdoc cref="M:KKAPI.Utilities.Extensions.Attempt``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})"/>
        </member>
        <member name="M:KKAPI.Utilities.Extensions.FancyDestroy(UnityEngine.GameObject,System.Boolean,System.Boolean)">
            <summary>
            Destroy this GameObject. Safe to use on null objects.
            </summary>
            <param name="self">Object to destroy</param>
            <param name="useDestroyImmediate">Use DestroyImmediate instead of Destroy</param>
            <param name="detachParent">Set parent of the object to null before destroying it (useful when doing FindInChildren and such immediately after destroying to make sure that this destroyed object isn't included in the results)</param>
        </member>
        <member name="M:KKAPI.Utilities.Extensions.GetFullPath(UnityEngine.GameObject)">
            <summary>
            Get full GameObject "path" to this GameObject.
            Example: RootObject\ChildObject1\ChildObject2
            </summary>
        </member>
        <member name="M:KKAPI.Utilities.Extensions.GetFullPath(UnityEngine.Component)">
            <summary>
            Get full GameObject "path" to this Component.
            Example: RootObject\ChildObject1\ChildObject2 [Renderer]
            </summary>
        </member>
        <member name="M:KKAPI.Utilities.Extensions.GetTopmostParent(UnityEngine.Component)">
            <summary>
            Get the topmost parent of Transform that this this Component is attached to.
            </summary>
        </member>
        <member name="M:KKAPI.Utilities.Extensions.GetTopmostParent(UnityEngine.GameObject)">
            <summary>
            Get the topmost parent of this GameObject.
            </summary>
        </member>
        <member name="M:KKAPI.Utilities.Extensions.GetTopmostParent(UnityEngine.Transform)">
            <summary>
            Get the topmost parent of this Transform.
            </summary>
        </member>
        <member name="M:KKAPI.Utilities.Extensions.IsDestroyed(UnityEngine.Object)">
            <summary>
            Return true if the object is a "fake" null (i.e. it was destroyed).
            </summary>
        </member>
        <member name="M:KKAPI.Utilities.Extensions.GetPropertyValue(System.Object,System.String,System.Object@)">
            <summary>
            Get value of a property through reflection
            </summary>
            <param name="self">Object that has the property</param>
            <param name="name">Name of the property</param>
            <param name="value">Value returned by the property</param>
            <returns>True if the property exists, flase if it doesn't</returns>
        </member>
        <member name="M:KKAPI.Utilities.Extensions.SetPropertyValue(System.Object,System.String,System.Object)">
            <summary>
            Set value of a property through reflection
            </summary>
            <param name="self">Object that has the property</param>
            <param name="name">Name of the property</param>
            <param name="value">Value to be set to the property</param>
            <returns>True if the property exists, flase if it doesn't</returns>
        </member>
        <member name="M:KKAPI.Utilities.Extensions.GetFieldValue(System.Object,System.String,System.Object@)">
            <summary>
            Get value of a field through reflection
            </summary>
            <param name="self">Object that has the field</param>
            <param name="name">Name of the field</param>
            <param name="value">Value returned by the field</param>
            <returns>True if the field exists, flase if it doesn't</returns>
        </member>
        <member name="M:KKAPI.Utilities.Extensions.SetFieldValue(System.Object,System.String,System.Object)">
            <summary>
            Set value of a field through reflection
            </summary>
            <param name="self">Object that has the field</param>
            <param name="name">Name of the property</param>
            <param name="value">Value to be set to the field</param>
            <returns>True if the field exists, flase if it doesn't</returns>
        </member>
        <member name="T:KKAPI.Utilities.TranslationHelper">
            <summary>
            Class that abstracts away AutoTranslator. It lets you translate text to current language.
            </summary>
        </member>
        <member name="P:KKAPI.Utilities.TranslationHelper.AutoTranslatorInstalled">
            <summary>
            True if a reasonably recent version of AutoTranslator is installed.
            It might return false for some very old versions that don't have the necessary APIs to make this class work.
            </summary>
        </member>
        <member name="M:KKAPI.Utilities.TranslationHelper.TranslateAsync(System.String,System.Action{System.String})">
            <summary>
            Queries AutoTranslator to provide a translated text for the untranslated text.
            If the translation cannot be found in the cache, it will make a request to the translator selected by the user.
            If AutoTranslator is not installed, this will do nothing.
            </summary>
            <param name="untranslatedText">The untranslated text to provide a translation for.</param>
            <param name="onCompleted">Callback with the completed translation. It can return immediately or at some later point.</param>
        </member>
        <member name="M:KKAPI.Utilities.TranslationHelper.TryTranslate(System.String,System.String@)">
            <summary>
            Queries the plugin to provide a translated text for the untranslated text.
            If the translation cannot be found in the cache, the method returns false
            and returns null as the untranslated text.
            </summary>
            <param name="untranslatedText">The untranslated text to provide a translation for.</param>
            <param name="translatedText">The translated text.</param>
        </member>
        <member name="T:KKAPI.Utilities.WindowsStringComparer">
            <summary>
            String comparer that is equivalent to the one used by Windows Explorer to sort files (e.g. 2 will go before 10, unlike normal compare).
            </summary>
            <inheritdoc />
        </member>
        <member name="M:KKAPI.Utilities.WindowsStringComparer.Compare(System.String,System.String)">
            <summary>
            Compare two strings with rules used by Windows Explorer to logically sort files.
            </summary>
        </member>
        <member name="M:KKAPI.Utilities.WindowsStringComparer.LogicalCompare(System.String,System.String)">
            <summary>
            Compare two strings with rules used by Windows Explorer to logically sort files.
            </summary>
        </member>
        <member name="T:KKAPI.Studio.SaveLoad.ObjectDeletedEventArgs">
            <summary>
            Arguments used in object deleted events
            </summary>
            <inheritdoc />
        </member>
        <member name="M:KKAPI.Studio.SaveLoad.ObjectDeletedEventArgs.#ctor(Studio.ObjectCtrlInfo)">
            <inheritdoc />
            <param name="deletedObject">Object being deleted</param>
        </member>
        <member name="P:KKAPI.Studio.SaveLoad.ObjectDeletedEventArgs.DeletedObject">
            <summary>
            Object deleted by the event
            </summary>
        </member>
        <member name="T:KKAPI.Studio.SaveLoad.ObjectsCopiedEventArgs">
            <summary>
            Arguments used in objects copied events
            </summary>
            <inheritdoc />
        </member>
        <member name="M:KKAPI.Studio.SaveLoad.ObjectsCopiedEventArgs.#ctor(KKAPI.Utilities.ReadOnlyDictionary{System.Int32,Studio.ObjectCtrlInfo})">
            <inheritdoc />
            <param name="loadedObjects">Objects copied by the event</param>
        </member>
        <member name="P:KKAPI.Studio.SaveLoad.ObjectsCopiedEventArgs.LoadedObjects">
            <summary>
            Objects copied by the event and their original IDs
            </summary>
        </member>
        <member name="T:KKAPI.Studio.SaveLoad.ObjectsSelectedEventArgs">
            <summary>
            Arguments used in object deleted events
            </summary>
            <inheritdoc />
        </member>
        <member name="M:KKAPI.Studio.SaveLoad.ObjectsSelectedEventArgs.#ctor(System.Collections.Generic.List{Studio.ObjectCtrlInfo})">
            <inheritdoc />
            <param name="selectedObjects">Objects being selected</param>
        </member>
        <member name="P:KKAPI.Studio.SaveLoad.ObjectsSelectedEventArgs.SelectedObjects">
            <summary>
            Object modified by the event
            </summary>
        </member>
        <member name="T:KKAPI.Studio.SaveLoad.ObjectVisibilityToggledEventArgs">
            <summary>
            Arguments used in object deleted events
            </summary>
            <inheritdoc />
        </member>
        <member name="M:KKAPI.Studio.SaveLoad.ObjectVisibilityToggledEventArgs.#ctor(Studio.ObjectCtrlInfo,System.Boolean)">
            <inheritdoc />
            <param name="toggledObject">Object being toggled</param>
            <param name="visible">Visibility of the object</param>
        </member>
        <member name="P:KKAPI.Studio.SaveLoad.ObjectVisibilityToggledEventArgs.ToggledObject">
            <summary>
            Object being toggled
            </summary>
        </member>
        <member name="P:KKAPI.Studio.SaveLoad.ObjectVisibilityToggledEventArgs.Visible">
            <summary>
            Visibility of the object
            </summary>
        </member>
        <member name="T:KKAPI.Studio.SaveLoad.SceneCustomFunctionController">
            <summary>
            Base type for custom scene/studio extensions.
            It provides many useful methods that abstract away the nasty hooks needed to figure out when
            a scene is loaded or imported, or how to save and load your custom data to the scene file.
            
            This controller is a MonoBehaviour that is created upon registration in <see cref="M:KKAPI.Studio.SaveLoad.StudioSaveLoadApi.RegisterExtraBehaviour``1(System.String)"/>. 
            The controller is created only once. If it's created too late it might miss some scene load events.
            It's recommended to register controllers in your Start method.
            </summary>
        </member>
        <member name="M:KKAPI.Studio.SaveLoad.SceneCustomFunctionController.OnSceneLoad(KKAPI.Studio.SaveLoad.SceneOperationKind,KKAPI.Utilities.ReadOnlyDictionary{System.Int32,Studio.ObjectCtrlInfo})">
            <summary>
            Fired when a scene is successfully changed, either by loading, importing or resetting.
            </summary>
            <param name="operation">Operation that caused this event</param>
            <param name="loadedItems">A dictionary of items loaded by this operation and their original IDs.
            The IDs are identical to the IDs at the time of saving the scene, even during import.
            Warning: The IDs here might not be the same as IDs of the objects in the scene!
            To get current scene ID of the object call <see cref="M:KKAPI.Studio.StudioObjectExtensions.GetSceneId(Studio.ObjectCtrlInfo)"/></param>
        </member>
        <member name="M:KKAPI.Studio.SaveLoad.SceneCustomFunctionController.OnSceneSave">
            <summary>
            Fired when a scene is about to be saved and any exteneded data needs to be written.
            </summary>
        </member>
        <member name="M:KKAPI.Studio.SaveLoad.SceneCustomFunctionController.OnObjectsCopied(KKAPI.Utilities.ReadOnlyDictionary{System.Int32,Studio.ObjectCtrlInfo})">
            <summary>
            Fired when objects are copied.
            </summary>
            <param name="copiedItems">A dictionary of items loaded by this operation and their original IDs.
            The IDs match the original object in the scene.
            To get current scene ID of the object call <see cref="M:KKAPI.Studio.StudioObjectExtensions.GetSceneId(Studio.ObjectCtrlInfo)"/></param>
        </member>
        <member name="M:KKAPI.Studio.SaveLoad.SceneCustomFunctionController.OnObjectDeleted(Studio.ObjectCtrlInfo)">
            <summary>
            Fired when objects are deleted.
            </summary>
            <param name="objectCtrlInfo">ObjectCtrlInfo associated with the item being deleted</param>
        </member>
        <member name="M:KKAPI.Studio.SaveLoad.SceneCustomFunctionController.OnObjectVisibilityToggled(Studio.ObjectCtrlInfo,System.Boolean)">
            <summary>
            Fired when objects have their visibility toggled.
            </summary>
            <param name="objectCtrlInfo">ObjectCtrlInfo associated with the item being toggled</param>
            <param name="visible">Visibility of the object</param>
        </member>
        <member name="M:KKAPI.Studio.SaveLoad.SceneCustomFunctionController.OnObjectsSelected(System.Collections.Generic.List{Studio.ObjectCtrlInfo})">
            <summary>
            Fired when objects are selected.
            </summary>
            <param name="objectCtrlInfo">ObjectCtrlInfo associated with the item being selected</param>
        </member>
        <member name="P:KKAPI.Studio.SaveLoad.SceneCustomFunctionController.ExtendedDataId">
            <summary>
            ID used for extended data by this controller. It's set when registering the controller
            with <see cref="M:KKAPI.Studio.SaveLoad.StudioSaveLoadApi.RegisterExtraBehaviour``1(System.String)"/>
            </summary>
        </member>
        <member name="M:KKAPI.Studio.SaveLoad.SceneCustomFunctionController.GetExtendedData">
            <summary>
            Get extended data of the last loaded scene by using the ID you specified when registering this controller.
            </summary>
        </member>
        <member name="M:KKAPI.Studio.SaveLoad.SceneCustomFunctionController.SetExtendedData(ExtensibleSaveFormat.PluginData)">
            <summary>
            Save your custom data to the scene under the ID you specified when registering this controller.
            </summary>
            <param name="data">Your custom data to be written to the scene. Can be null to remove the data.</param>
        </member>
        <member name="M:KKAPI.Studio.SaveLoad.SceneCustomFunctionController.GetStudio">
            <summary>
            Get the instance of the Studio game manager object.
            </summary>
        </member>
        <member name="T:KKAPI.Studio.SaveLoad.SceneLoadEventArgs">
            <summary>
            Arguments used in scene loaded/imported events
            </summary>
            <inheritdoc />
        </member>
        <member name="M:KKAPI.Studio.SaveLoad.SceneLoadEventArgs.#ctor(KKAPI.Studio.SaveLoad.SceneOperationKind,KKAPI.Utilities.ReadOnlyDictionary{System.Int32,Studio.ObjectCtrlInfo})">
            <inheritdoc />
            <param name="operation">Operation that caused the event</param>
            <param name="loadedObjects">Objects loaded by the event</param>
        </member>
        <member name="P:KKAPI.Studio.SaveLoad.SceneLoadEventArgs.Operation">
            <summary>
            Operation that caused the event
            </summary>
        </member>
        <member name="P:KKAPI.Studio.SaveLoad.SceneLoadEventArgs.LoadedObjects">
            <summary>
            Objects loaded by the event and their original IDs (from the time the scene was saved)
            </summary>
        </member>
        <member name="T:KKAPI.Studio.SaveLoad.SceneOperationKind">
            <summary>
            Scene load/change operations
            </summary>
        </member>
        <member name="F:KKAPI.Studio.SaveLoad.SceneOperationKind.Load">
            <summary>
            Scene is being loaded and will replace what's currently loaded.
            </summary>
        </member>
        <member name="F:KKAPI.Studio.SaveLoad.SceneOperationKind.Import">
            <summary>
            Scene is being loaded and will be added to what's currently loaded. 
            <remarks>IDs in the scene will be different from the IDs in the file of the scene being imported, 
            use <see cref="T:KKAPI.Studio.SaveLoad.SceneCustomFunctionController"/> to get IDs from the scene file.</remarks>
            </summary>
        </member>
        <member name="F:KKAPI.Studio.SaveLoad.SceneOperationKind.Clear">
            <summary>
            Scene is being cleared of all state (by default, only user clicking the "Reset" button can trigger this).
            This is not triggered when studio starts.
            </summary>
        </member>
        <member name="T:KKAPI.Studio.SaveLoad.StudioSaveLoadApi">
            <summary>
            Provides API for loading and saving scenes, as well as a convenient way for registering custom studio functions.
            </summary>
        </member>
        <member name="M:KKAPI.Studio.SaveLoad.StudioSaveLoadApi.RegisterExtraBehaviour``1(System.String)">
            <summary>
            Register new functionality that will be added to studio. Offers easy API for saving and loading extended data.
            All necessary hooking and event subscribing is done for you. Importing scenes is also handled for you.
            All you have to do is create a type that inherits from <see cref="T:KKAPI.Studio.SaveLoad.SceneCustomFunctionController"/>>
            (don't make instances, the API will make them for you). Warning: The custom controller is immediately
            created when it's registered, but its OnSceneLoad method is not called until a scene actually loads.
            This might mean that if the registration happens too late you will potentially miss some load events. 
            </summary>
            <typeparam name="T">Type with your custom logic to add to a character</typeparam>
            <param name="extendedDataId">Extended data ID used by this behaviour. Set to null if not used.</param>
        </member>
        <member name="E:KKAPI.Studio.SaveLoad.StudioSaveLoadApi.SceneLoad">
            <summary>
            Fired right after a scene is succesfully imported, loaded or cleared. 
            Runs immediately after all <see cref="T:KKAPI.Studio.SaveLoad.SceneCustomFunctionController"/> objects trigger their events.
            </summary>
        </member>
        <member name="E:KKAPI.Studio.SaveLoad.StudioSaveLoadApi.SceneSave">
            <summary>
            Fired right before a scene is saved to file. 
            Runs immediately after all <see cref="T:KKAPI.Studio.SaveLoad.SceneCustomFunctionController"/> objects trigger their events.
            </summary>
        </member>
        <member name="E:KKAPI.Studio.SaveLoad.StudioSaveLoadApi.ObjectsCopied">
            <summary>
            Fired when objects in the scene are copied
            </summary>
        </member>
        <member name="E:KKAPI.Studio.SaveLoad.StudioSaveLoadApi.ObjectDeleted">
            <summary>
            Fired when an object in the scene is being deleted
            </summary>
        </member>
        <member name="E:KKAPI.Studio.SaveLoad.StudioSaveLoadApi.ObjectVisibilityToggled">
            <summary>
            Fired when an object in the scene had its visibility toggled
            </summary>
        </member>
        <member name="E:KKAPI.Studio.SaveLoad.StudioSaveLoadApi.ObjectsSelected">
            <summary>
            Fired when an object in the scene is selected
            </summary>
        </member>
        <member name="P:KKAPI.Studio.SaveLoad.StudioSaveLoadApi.ImportInProgress">
            <summary>
            A scene is currently being imported
            </summary>
        </member>
        <member name="P:KKAPI.Studio.SaveLoad.StudioSaveLoadApi.LoadInProgress">
            <summary>
            A scene is currently being loaded (not imported or cleared)
            </summary>
        </member>
        <member name="F:KKAPI.Studio.SaveLoad.StudioSaveLoadApi.Hooks.ImportDictionary">
            <summary>
            A lookup for original dicKey IDs. It is generated on scene import, and only useful then.
            Key is the new ID in the scene (needs to be used currently), while Value is the old ID
            in the save file (same as at the time scene was saved).
            </summary>
        </member>
        <member name="M:KKAPI.Studio.SaveLoad.StudioSaveLoadApi.Hooks.ObjectInfoLoadTranspiler(System.Collections.Generic.IEnumerable{HarmonyLib.CodeInstruction})">
            <summary>
            The original code reads the dicKey of an object on import and does nothing with it. Capture that variable and use it to
            construct an import dictionary.
            GetNewIndex is called before this and will be used to get the dicKey used in the scene.
            </summary>
        </member>
        <member name="T:KKAPI.Studio.StudioAPI">
            <summary>
            Provides a way to add custom menu items to CharaStudio, and gives useful methods for interfacing with the studio.
            </summary>
        </member>
        <member name="M:KKAPI.Studio.StudioAPI.CreateCurrentStateCategory(KKAPI.Studio.UI.CurrentStateCategory)">
            <summary>
            Add a new custom category to the Anim > CurrentState tab in the studio top-left menu.
            Can use this at any point.
            </summary>
        </member>
        <member name="M:KKAPI.Studio.StudioAPI.GetOrCreateCurrentStateCategory(System.String)">
            <summary>
            Add a new custom category to the Anim > CurrentState tab in the studio top-left menu.
            Can use this at any point. Always returns null outside of studio.
            If the name is empty or null, the Misc/Other category is returned.
            </summary>
        </member>
        <member name="M:KKAPI.Studio.StudioAPI.GetSelectedControllers``1">
            <summary>
            Get all instances of this controller that belong to characters that are selected in Studio's Workspace.
            </summary>
        </member>
        <member name="M:KKAPI.Studio.StudioAPI.GetSelectedCharacters">
            <summary>
            Get all character objects currently selected in Studio's Workspace.
            </summary>
        </member>
        <member name="M:KKAPI.Studio.StudioAPI.GetSelectedObjects">
            <summary>
            Get all objects (all types) currently selected in Studio's Workspace.
            </summary>
        </member>
        <member name="P:KKAPI.Studio.StudioAPI.InsideStudio">
            <summary>
            True if we are currently inside CharaStudio.exe
            </summary>
        </member>
        <member name="P:KKAPI.Studio.StudioAPI.StudioLoaded">
            <summary>
            True inside studio after it finishes loading the interface (when the starting loading screen finishes), 
            right before custom controls are created.
            </summary>
        </member>
        <member name="E:KKAPI.Studio.StudioAPI.StudioLoadedChanged">
            <summary>
            Fires once after studio finished loading the interface, right before custom controls are created.
            </summary>
        </member>
        <member name="T:KKAPI.Studio.StudioObjectExtensions">
            <summary>
            Useful extensions for studio metaobjects
            </summary>
        </member>
        <member name="M:KKAPI.Studio.StudioObjectExtensions.GetObjectCtrlInfo(Studio.ObjectInfo)">
            <summary>
            Get the ObjectCtrlInfo object that uses this ObjectInfo.
            If the object was not found in current scene, null is returned.
            </summary>
        </member>
        <member name="M:KKAPI.Studio.StudioObjectExtensions.GetSceneId(Studio.ObjectCtrlInfo)">
            <summary>
            Get the ID of this object as used in the currently loaded scene.
            If the object was not found in current scene, -1 is returned.
            </summary>
        </member>
        <member name="M:KKAPI.Studio.StudioObjectExtensions.GetSceneId(Studio.ObjectInfo)">
            <summary>
            Get the ID of this object as used in the currently loaded scene.
            If the object was not found in current scene, -1 is returned.
            </summary>
        </member>
        <member name="M:KKAPI.Studio.StudioObjectExtensions.GetOCIChar(AIChara.ChaControl)">
            <summary>
            Get GetOCIChar that is assigned to this character. Only works in CharaStudio, returns null elsewhere.
            </summary>
        </member>
        <member name="M:KKAPI.Studio.StudioObjectExtensions.GetChaControl(Studio.OCIChar)">
            <summary>
            Get character component for this studio object
            </summary>
        </member>
        <member name="T:KKAPI.Studio.UI.BaseCurrentStateEditableGuiEntry`1">
            <summary>
            Base class of controls that hold a value. 
            Subscribe to <see cref="P:KKAPI.Studio.UI.BaseCurrentStateEditableGuiEntry`1.Value"/> to update your control's state whenever the value changes.
            </summary>
            <typeparam name="T">Type of the held value</typeparam>
        </member>
        <member name="M:KKAPI.Studio.UI.BaseCurrentStateEditableGuiEntry`1.#ctor(System.String,System.Func{Studio.OCIChar,`0},`0)">
            <summary>
            Create a new control that holds a value
            </summary>
            <param name="name">Name of the control</param>
            <param name="updateValue">Function called every time current character changes and the value needs to be updated</param>
            <param name="initialValue">Initial value used before first updateValue call</param>
        </member>
        <member name="P:KKAPI.Studio.UI.BaseCurrentStateEditableGuiEntry`1.Value">
            <summary>
            Current value of this control
            </summary>
        </member>
        <member name="M:KKAPI.Studio.UI.BaseCurrentStateEditableGuiEntry`1.OnUpdateInfo(Studio.OCIChar)">
            <inheritdoc />
        </member>
        <member name="T:KKAPI.Studio.UI.CurrentStateCategory">
            <summary>
            Category under the Anim > CustomState tab
            </summary>
        </member>
        <member name="M:KKAPI.Studio.UI.CurrentStateCategory.#ctor(System.String,System.Collections.Generic.IEnumerable{KKAPI.Studio.UI.CurrentStateCategorySubItemBase})">
            <summary>
            Create a new custom CurrentState category
            </summary>
            <param name="categoryName">Name of the category</param>
            <param name="subItems">Controls under this category</param>
        </member>
        <member name="M:KKAPI.Studio.UI.CurrentStateCategory.#ctor(System.String)">
            <summary>
            Create a new custom CurrentState category
            </summary>
        </member>
        <member name="P:KKAPI.Studio.UI.CurrentStateCategory.CategoryName">
            <summary>
            Name of the category. Controls are drawn under it.
            </summary>
        </member>
        <member name="P:KKAPI.Studio.UI.CurrentStateCategory.SubItems">
            <summary>
            All custom controls under this category.
            </summary>
        </member>
        <member name="M:KKAPI.Studio.UI.CurrentStateCategory.CreateCategory(UnityEngine.GameObject)">
            <summary>
            Used by the API to actually create the custom control object
            </summary>
        </member>
        <member name="P:KKAPI.Studio.UI.CurrentStateCategory.Created">
            <summary>
            The category was created and still exists.
            </summary>
        </member>
        <member name="M:KKAPI.Studio.UI.CurrentStateCategory.UpdateInfo(Studio.OCIChar)">
            <summary>
            Fired when currently selected character changes and the controls need to be updated
            </summary>
            <param name="ociChar">Newly selected character</param>
        </member>
        <member name="M:KKAPI.Studio.UI.CurrentStateCategory.AddControl``1(``0)">
            <summary>
            Add new control to this category
            </summary>
        </member>
        <member name="M:KKAPI.Studio.UI.CurrentStateCategory.AddControls(KKAPI.Studio.UI.CurrentStateCategorySubItemBase[])">
            <summary>
            Add new controls to this category
            </summary>
        </member>
        <member name="T:KKAPI.Studio.UI.CurrentStateCategoryDropdown">
            <summary>
            Custom control that draws a dropdown menu in the Chara > CurrentState studio menu.
            </summary>
        </member>
        <member name="M:KKAPI.Studio.UI.CurrentStateCategoryDropdown.#ctor(System.String,System.String[],System.Func{Studio.OCIChar,System.Int32})">
            <summary>
            A dropdown for the Chara > CurrentState studio menu.
            </summary>
            <param name="name">Name of the button, shown on left.</param>
            <param name="items">Items shown in the dropdown box. Value is the currently selected index.</param>
            <param name="updateValue">Function called when the current character changes and the on/off state needs to be updated.
            <code>OCIChar</code> is the newly selected character. Return the new state. Can't be null.</param>
        </member>
        <member name="M:KKAPI.Studio.UI.CurrentStateCategoryDropdown.CreateItem(UnityEngine.GameObject)">
            <inheritdoc />
        </member>
        <member name="T:KKAPI.Studio.UI.CurrentStateCategorySlider">
            <summary>
            Custom control that draws a slider in the Chara > CurrentState studio menu.
            </summary>
        </member>
        <member name="P:KKAPI.Studio.UI.CurrentStateCategorySlider.MinValue">
            <summary>
            Minimum value of the slider
            </summary>
        </member>
        <member name="P:KKAPI.Studio.UI.CurrentStateCategorySlider.MaxValue">
            <summary>
            Maximum value of the slider
            </summary>
        </member>
        <member name="M:KKAPI.Studio.UI.CurrentStateCategorySlider.#ctor(System.String,System.Func{Studio.OCIChar,System.Single},System.Single,System.Single)">
            <summary>
            Custom control that draws a slider in the Chara > CurrentState studio menu.
            </summary>
            <param name="name">Name of the button, shown on left</param> 
            <param name="updateValue">Function called when the current character changes and the slider value needs to be updated.
            <code>OCIChar</code> is the newly selected character. Return the new state. Can't be null.</param>
            <param name="minValue">Minimum value of the slider</param>
            <param name="maxValue">Maximum value of the slider</param>
        </member>
        <member name="M:KKAPI.Studio.UI.CurrentStateCategorySlider.CreateItem(UnityEngine.GameObject)">
            <inheritdoc />
        </member>
        <member name="T:KKAPI.Studio.UI.CurrentStateCategorySubItemBase">
            <summary>
            Base of custom controls created under CurrentState category
            </summary>
        </member>
        <member name="M:KKAPI.Studio.UI.CurrentStateCategorySubItemBase.#ctor(System.String)">
            <summary>
            Create a new custom CurrentState control
            </summary>
            <param name="name">Name of the setting displayed on the left</param>
        </member>
        <member name="P:KKAPI.Studio.UI.CurrentStateCategorySubItemBase.Name">
            <summary>
            Name of the setting, displayed to the left
            </summary>
        </member>
        <member name="M:KKAPI.Studio.UI.CurrentStateCategorySubItemBase.CreateItem(UnityEngine.GameObject)">
            <summary>
            Fired when API wants to create the control. Should return the control's root GameObject
            </summary>
            <param name="categoryObject">Parent object of the control to be created</param>
        </member>
        <member name="M:KKAPI.Studio.UI.CurrentStateCategorySubItemBase.OnUpdateInfo(Studio.OCIChar)">
            <summary>
            Fired when currently selected character changes and the control need to be updated
            </summary>
            <param name="ociChar">Newly selected character</param>
        </member>
        <member name="P:KKAPI.Studio.UI.CurrentStateCategorySubItemBase.RootGameObject">
            <summary>
            The control's root gameobject. null if the control was not created yet.
            </summary>
        </member>
        <member name="P:KKAPI.Studio.UI.CurrentStateCategorySubItemBase.Created">
            <summary>
            The control was created and still exists.
            </summary>
        </member>
        <member name="P:KKAPI.Studio.UI.CurrentStateCategorySubItemBase.Visible">
            <summary>
            The control is visible to the user (usually the same as it's GameObject being active).
            </summary>
        </member>
        <member name="T:KKAPI.Studio.UI.CurrentStateCategoryToggle">
            <summary>
            Custom control that draws from 2 to 4 radio buttons (they are drawn like toggles)
            </summary>
        </member>
        <member name="P:KKAPI.Studio.UI.CurrentStateCategoryToggle.ToggleCount">
            <summary>
            Number of the radio buttons, can be 2, 3 or 4
            </summary>
        </member>
        <member name="M:KKAPI.Studio.UI.CurrentStateCategoryToggle.#ctor(System.String,System.Int32,System.Func{Studio.OCIChar,System.Int32})">
            <summary>
            A toggle list for the Chara &gt; CurrentState studio menu.
            </summary>
            <param name="name">Name of the list, shown on left</param>
            <param name="toggleCount">Number of the toggles, can be 2, 3 or 4</param>
            <param name="onUpdateSelection">Function called when the current character changes and the selected index needs to be updated.
            <code>OCIChar</code> is the newly selected character. Return the new selected index. Can't be null.</param>
        </member>
        <member name="P:KKAPI.Studio.UI.CurrentStateCategoryToggle.SelectedIndex">
            <summary>
            Currently selected button (starts at 0)
            </summary>
        </member>
        <member name="M:KKAPI.Studio.UI.CurrentStateCategoryToggle.CreateItem(UnityEngine.GameObject)">
            <inheritdoc />
        </member>
        <member name="T:KKAPI.Studio.UI.CurrentStateCategorySwitch">
            <summary>
            Custom control that draws a single, circular button with an on/off state in the Chara > CurrentState studio menu.
            </summary>
        </member>
        <member name="M:KKAPI.Studio.UI.CurrentStateCategorySwitch.#ctor(System.String,System.Func{Studio.OCIChar,System.Boolean})">
            <summary>
            A single button for the Chara > CurrentState studio menu.
            </summary>
            <param name="name">Name of the button, shown on left</param> 
            <param name="updateValue">Function called when the current character changes and the on/off state needs to be updated.
            <code>OCIChar</code> is the newly selected character. Return the new state. Can't be null.</param>
        </member>
        <member name="M:KKAPI.Studio.UI.CurrentStateCategorySwitch.CreateItem(UnityEngine.GameObject)">
            <inheritdoc />
        </member>
        <member name="T:KKAPI.Studio.UI.CustomToolbarButtons">
            <summary>
            Add custom buttons to studio toolbars
            </summary>
        </member>
        <member name="M:KKAPI.Studio.UI.CustomToolbarButtons.AddLeftToolbarToggle(UnityEngine.Texture2D,System.Boolean,System.Action{System.Boolean})">
            <summary>
            Add a toggle button to the top of the left studio toolbar.
            Clicking on the button will toggle it between being on and off.
            </summary>
            <param name="iconTex">
            A 32x32 icon used for the button.
            You can find a template here
            https://github.com/IllusionMods/IllusionModdingAPI/blob/master/doc/studio%20icon%20template.png
            For best performance and smallest size save your thumbnail as 8bit grayscale png (or indexed if you need colors) with no alpha channel.
            </param>
            <param name="initialValue">Initial state of the toggle.</param>
            <param name="onValueChanged">
            Action fired each time user clicks on the toggle button.
            The value is true if the toggle is enabled by the click, false if disabled.
            </param>
        </member>
        <member name="M:KKAPI.Studio.UI.CustomToolbarButtons.AddLeftToolbarButton(UnityEngine.Texture2D,System.Action)">
            <summary>
            Add a simple button to the top of the left studio toolbar.
            </summary>
            ///
            <param name="iconTex">
            A 32x32 icon used for the button.
            You can find a template here
            https://github.com/ManlyMarco/QuickAccessBox/blob/master/Shared_QuickAccessBox/UI/toolbar-icon.png
            </param>
            <param name="onClicked">Action fired each time user clicks on the button</param>
        </member>
        <member name="T:KKAPI.Studio.UI.SceneEffectsCategory">
            <summary>
            Class that adds a new subcategory to the Scene Effects menu. Create a new instance and then add SliderSets and ToggleSets.
            </summary>
        </member>
        <member name="P:KKAPI.Studio.UI.SceneEffectsCategory.Header">
            <summary>
            Element that contains the header of the category.
            </summary>
        </member>
        <member name="P:KKAPI.Studio.UI.SceneEffectsCategory.Content">
            <summary>
            Element that contains the content of the category.
            </summary>
        </member>
        <member name="F:KKAPI.Studio.UI.SceneEffectsCategory.Toggles">
            <summary>
            Toggles that have been added.
            </summary>
        </member>
        <member name="F:KKAPI.Studio.UI.SceneEffectsCategory.Sliders">
            <summary>
            Sliders that have been added.
            </summary>
        </member>
        <member name="M:KKAPI.Studio.UI.SceneEffectsCategory.#ctor(System.String)">
            <summary>
            Create a new Screen Effects subcategory.
            </summary>
            <param name="labelText">Text that will appear on the header of the category</param>
        </member>
        <member name="M:KKAPI.Studio.UI.SceneEffectsCategory.AddToggleSet(System.String,System.Action{System.Boolean},System.Boolean)">
            <summary>
            Add a toggle to this Screen Effects subcategory.
            </summary>
            <param name="text">Label text</param>
            <param name="setter">Method to be called when the toggle changes value</param>
            <param name="initialValue">Initial state of the toggle</param>
            <returns>Instance of the ToggleSet</returns>
        </member>
        <member name="M:KKAPI.Studio.UI.SceneEffectsCategory.AddSliderSet(System.String,System.Action{System.Single},System.Single,System.Single,System.Single)">
            <summary>
            Add a slider with text box to this Screen Effects subcategory.
            </summary>
            <param name="text">Label text</param>
            <param name="setter">Method to be called when the slider or text box changes value</param>
            <param name="initialValue">Initial value of the slider and text box</param>
            <param name="sliderMinimum">Minimum value the slider can slide. Can be overriden by the user typing in to the text box if EnforceSliderMinimum is set to false.</param>
            <param name="sliderMaximum">Maximum value the slider can slide. Can be overriden by the user typing in to the text box if EnforceSliderMaximum is set to false.</param>
            <returns>Instance of the SliderSet</returns>
        </member>
        <member name="T:KKAPI.Studio.UI.SceneEffectsSliderSet">
            <summary>
            A container for the value of a slider, associated label, slider, textbox, and reset button UI elements, and the setter method that triggers on value change.
            </summary>
        </member>
        <member name="P:KKAPI.Studio.UI.SceneEffectsSliderSet.Label">
            <summary>
            Label UI element.
            </summary>
        </member>
        <member name="P:KKAPI.Studio.UI.SceneEffectsSliderSet.Slider">
            <summary>
            Slider UI element.
            </summary>
        </member>
        <member name="P:KKAPI.Studio.UI.SceneEffectsSliderSet.Input">
            <summary>
            Input field UI element.
            </summary>
        </member>
        <member name="P:KKAPI.Studio.UI.SceneEffectsSliderSet.Button">
            <summary>
            Reset button UI element.
            </summary>
        </member>
        <member name="P:KKAPI.Studio.UI.SceneEffectsSliderSet.Setter">
            <summary>
            Method called when the value of the toggle is changed.
            </summary>
        </member>
        <member name="P:KKAPI.Studio.UI.SceneEffectsSliderSet.InitialValue">
            <summary>
            Initial state of the toggle.
            </summary>
        </member>
        <member name="F:KKAPI.Studio.UI.SceneEffectsSliderSet.ShowInput">
            <summary>
            Show the input field for typing in values.
            todo Not actually working?
            </summary>
        </member>
        <member name="F:KKAPI.Studio.UI.SceneEffectsSliderSet.ShowButton">
            <summary>
            Show the reset button.
            todo Not actually working?
            </summary>
        </member>
        <member name="P:KKAPI.Studio.UI.SceneEffectsSliderSet.SliderMinimum">
            <summary>
            Minimum value the slider can slide. Can be overriden by the user typing in the textbox if EnforceSliderMinimum is set to false.
            </summary>
        </member>
        <member name="P:KKAPI.Studio.UI.SceneEffectsSliderSet.SliderMaximum">
            <summary>
            Maximum value the slider can slide. Can be overriden by the user typing in the textbox if EnforceSliderMaximum is set to false.
            </summary>
        </member>
        <member name="P:KKAPI.Studio.UI.SceneEffectsSliderSet.EnforceSliderMinimum">
            <summary>
            Whether to enforce the SliderMinimum value. If false, users can type values in to the textbox that exceed the minimum value.
            </summary>
        </member>
        <member name="P:KKAPI.Studio.UI.SceneEffectsSliderSet.EnforceSliderMaximum">
            <summary>
            Whether to enforce the SliderMaximum value. If false, users can type values in to the textbox that exceed the maximum value.
            </summary>
        </member>
        <member name="P:KKAPI.Studio.UI.SceneEffectsSliderSet.Text">
            <summary>
            Get or set the text of the label.
            </summary>
        </member>
        <member name="P:KKAPI.Studio.UI.SceneEffectsSliderSet.Value">
            <summary>
            Get or set the value of the toggle.
            </summary>
        </member>
        <member name="M:KKAPI.Studio.UI.SceneEffectsSliderSet.#ctor(TMPro.TextMeshProUGUI,UnityEngine.UI.Slider,System.String,System.Action{System.Single},System.Single,System.Single,System.Single)">
            <summary>
            Create a new SliderSet. Typically you want to use SceneEffectsCategory.AddSliderSet instead of creating these manually.
            </summary>
            <param name="label">Label UI element</param>
            <param name="slider">Slider UI element</param>
            <param name="text">Label text</param>
            <param name="setter">Method that will be called on value change</param>
            <param name="initialValue">Initial value of the slider and textbox</param>
            <param name="sliderMinimum">Minimum value of the slider and textbox</param>
            <param name="sliderMaximum">Maximum value of the slider and textbox</param>
        </member>
        <member name="M:KKAPI.Studio.UI.SceneEffectsSliderSet.#ctor(TMPro.TextMeshProUGUI,UnityEngine.UI.Slider,UnityEngine.UI.InputField,UnityEngine.UI.Button,System.String,System.Action{System.Single},System.Single,System.Single,System.Single)">
            <summary>
            Create a new SliderSet. Typically you want to use SceneEffectsCategory.AddSliderSet instead of creating these manually.
            </summary>
            <param name="label">Label UI element</param>
            <param name="slider">Slider UI element</param>
            <param name="input">Input field UI element</param>
            <param name="button">Reset button UI element</param>
            <param name="text">Label text</param>
            <param name="setter">Method that will be called on value change</param>
            <param name="initialValue">Initial value of the slider and textbox</param>
            <param name="sliderMinimum">Minimum value of the slider and textbox</param>
            <param name="sliderMaximum">Maximum value of the slider and textbox</param>
        </member>
        <member name="M:KKAPI.Studio.UI.SceneEffectsSliderSet.GetValue">
            <summary>
            Get the value of the slider set.
            </summary>
            <returns>Value of the slider set</returns>
        </member>
        <member name="M:KKAPI.Studio.UI.SceneEffectsSliderSet.SetValue(System.String)">
            <summary>
            Set the value of the slider set, update the UI elements, and trigger the Setter method.
            </summary>
            <param name="value">Value to set the toggle set</param>
        </member>
        <member name="M:KKAPI.Studio.UI.SceneEffectsSliderSet.SetValue(System.String,System.Boolean)">
            <summary>
            Set the value of the slider set and update the UI elements.
            </summary>
            <param name="value">Value to set the toggle set</param>
            <param name="triggerEvents">Whether to trigger the Setter method</param>
        </member>
        <member name="M:KKAPI.Studio.UI.SceneEffectsSliderSet.SetValue(System.Single)">
            <summary>
            Set the value of the slider set, update the UI elements, and trigger the Setter method.
            </summary>
            <param name="value">Value to set the toggle set</param>
        </member>
        <member name="M:KKAPI.Studio.UI.SceneEffectsSliderSet.SetValue(System.Single,System.Boolean)">
            <summary>
            Set the value of the slider set and update the UI elements.
            </summary>
            <param name="value">Value to set the toggle set</param>
            <param name="triggerEvents">Whether to trigger the Setter method</param>
        </member>
        <member name="M:KKAPI.Studio.UI.SceneEffectsSliderSet.Reset">
            <summary>
            Reset the slider set to the initial value, update UI elements, and trigger the Setter method.
            </summary>
        </member>
        <member name="M:KKAPI.Studio.UI.SceneEffectsSliderSet.Reset(System.Boolean)">
            <summary>
            Reset the slider set to the initial value and update UI elements.
            </summary>
            <param name="triggerEvents">Whether to trigger the Setter method</param>
        </member>
        <member name="T:KKAPI.Studio.UI.SceneEffectsToggleSet">
            <summary>
            A container for the value of a toggle, associated label and toggle UI elements, and the setter method that triggers on value change.
            </summary>
        </member>
        <member name="P:KKAPI.Studio.UI.SceneEffectsToggleSet.Label">
            <summary>
            Label UI element.
            </summary>
        </member>
        <member name="P:KKAPI.Studio.UI.SceneEffectsToggleSet.Toggle">
            <summary>
            Toggle UI element.
            </summary>
        </member>
        <member name="P:KKAPI.Studio.UI.SceneEffectsToggleSet.Setter">
            <summary>
            Method called when the value of the toggle is changed.
            </summary>
        </member>
        <member name="P:KKAPI.Studio.UI.SceneEffectsToggleSet.InitialValue">
            <summary>
            Initial state of the toggle.
            </summary>
        </member>
        <member name="P:KKAPI.Studio.UI.SceneEffectsToggleSet.Text">
            <summary>
            Get or set the text of the label.
            </summary>
        </member>
        <member name="P:KKAPI.Studio.UI.SceneEffectsToggleSet.Value">
            <summary>
            Get or set the value of the toggle.
            </summary>
        </member>
        <member name="M:KKAPI.Studio.UI.SceneEffectsToggleSet.#ctor(TMPro.TextMeshProUGUI,UnityEngine.UI.Toggle,System.String,System.Action{System.Boolean},System.Boolean)">
            <summary>
            Create a new ToggleSet. Typically you want to use SceneEffectsCategory.AddToggleSet instead of creating these manually.
            </summary>
            <param name="label">Label UI element</param>
            <param name="toggle">Toggle UI element</param>
            <param name="text">Label text</param>
            <param name="setter">Method that will be called on value change</param>
            <param name="initialValue">Initial state of the toggle</param>
        </member>
        <member name="M:KKAPI.Studio.UI.SceneEffectsToggleSet.GetValue">
            <summary>
            Get the value of the toggle.
            </summary>
            <returns>Value of the toggle</returns>
        </member>
        <member name="M:KKAPI.Studio.UI.SceneEffectsToggleSet.SetValue(System.Boolean)">
            <summary>
            Set the value of the toggle and trigger the Setter method.
            </summary>
            <param name="value">Value to set the toggle</param>
        </member>
        <member name="M:KKAPI.Studio.UI.SceneEffectsToggleSet.SetValue(System.Boolean,System.Boolean)">
            <summary>
            Set the value of the toggle.
            </summary>
            <param name="value">Value to set the toggle</param>
            <param name="triggerEvents">Whether to trigger the Setter method</param>
        </member>
        <member name="M:KKAPI.Studio.UI.SceneEffectsToggleSet.Reset">
            <summary>
            Reset the toggle to the initial value and trigger the Setter method.
            </summary>
        </member>
        <member name="M:KKAPI.Studio.UI.SceneEffectsToggleSet.Reset(System.Boolean)">
            <summary>
            Reset the toggle to the initial value.
            </summary>
            <param name="triggerEvents">Whether to trigger the Setter method</param>
        </member>
        <member name="T:KKAPI.Studio.UI.ToolbarButton">
            <summary>
            Custom toolbar button. Add using <see cref="M:KKAPI.Studio.UI.CustomToolbarButtons.AddLeftToolbarButton(UnityEngine.Texture2D,System.Action)"/>.
            </summary>
        </member>
        <member name="P:KKAPI.Studio.UI.ToolbarButton.Clicked">
            <summary>
            Triggered when the button is clicked.
            </summary>
        </member>
        <member name="M:KKAPI.Studio.UI.ToolbarButton.Initialize">
            <inheritdoc />
        </member>
        <member name="M:KKAPI.Studio.UI.ToolbarButton.OnCreateControl(UnityEngine.Transform)">
            <inheritdoc />
        </member>
        <member name="T:KKAPI.Studio.UI.ToolbarToggle">
            <summary>
            Custom toolbar toggle button. Add using <see cref="M:KKAPI.Studio.UI.CustomToolbarButtons.AddLeftToolbarToggle(UnityEngine.Texture2D,System.Boolean,System.Action{System.Boolean})"/>.
            </summary>
        </member>
        <member name="M:KKAPI.Studio.UI.ToolbarToggle.Initialize">
            <inheritdoc />
        </member>
        <member name="M:KKAPI.Studio.UI.ToolbarToggle.OnCreateControl(UnityEngine.Transform)">
            <inheritdoc />
        </member>
        <member name="T:KoiSkinOverlayX.TextureStorage">
            <summary>
            A class for storing textures that should be saved and loaded from extended data's <see cref="T:ExtensibleSaveFormat.PluginData"/> (e.g. to character cards and scenes).
            Duplicate textures are automatically handled so that only one copy of the texture is held in memory and saved.
            </summary>
        </member>
        <member name="M:KoiSkinOverlayX.TextureStorage.#ctor(UnityEngine.TextureFormat)">
            <summary>
            Create a new TextureStorage.
            </summary>
            <param name="format">Format of the loaded textures. It doesn't affect data saved to extended data.</param>
        </member>
        <member name="M:KoiSkinOverlayX.TextureStorage.PurgeUnused(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Remove unused textures based on a list of used IDs. Textures with IDs not in the list will be removed.
            </summary>
            <param name="usedIDs">A list of IDs to be kept if they exist</param>
        </member>
        <member name="M:KoiSkinOverlayX.TextureStorage.GetAllTextureIDs">
            <summary>
            Get IDs of all textures stored in this object.
            </summary>
        </member>
        <member name="M:KoiSkinOverlayX.TextureStorage.Clear(System.Boolean)">
            <summary>
            Clear the texture list and optionally destroy all textures.
            </summary>
        </member>
        <member name="M:KoiSkinOverlayX.TextureStorage.Load(ExtensibleSaveFormat.PluginData)">
            <summary>
            Load textures from extended data that were stored with <see cref="M:KoiSkinOverlayX.TextureStorage.Save(ExtensibleSaveFormat.PluginData)"/>.
            </summary>
        </member>
        <member name="M:KoiSkinOverlayX.TextureStorage.Save(ExtensibleSaveFormat.PluginData)">
            <summary>
            Save textures stored in this object to extended data. Can be loaded later with <see cref="M:KoiSkinOverlayX.TextureStorage.Load(ExtensibleSaveFormat.PluginData)"/>.
            </summary>
        </member>
        <member name="M:KoiSkinOverlayX.TextureStorage.StoreTexture(System.Byte[])">
            <summary>
            Store a texture and get an ID representing it. The ID can be used to get the texture with <see cref="M:KoiSkinOverlayX.TextureStorage.GetSharedTexture(System.Int32)"/>.
            If you try to store a texture that was already stored before, the ID of the previous texture is returned so there are no multiple identical textures stored.
            </summary>
            <param name="tex">Raw PNG data of the texture. If you reuse a texture make sure you always use the same PNG data or deduplicating won't work.</param>
        </member>
        <member name="M:KoiSkinOverlayX.TextureStorage.GetSharedTexture(System.Int32)">
            <summary>
            Get a texture based on texture ID. The same texture is returned every time, so it shouldn't be destroyed.
            </summary>
            <param name="id">ID of the texture you want to get. You get the ID when using <see cref="M:KoiSkinOverlayX.TextureStorage.StoreTexture(System.Byte[])"/>.</param>
            <returns></returns>
        </member>
    </members>
</doc>
